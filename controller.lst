   1               		.file	"controller.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.power_up,"ax",@progbits
  12               	power_up:
  13               	.LFB16:
  14               		.file 1 "controller.c"
   1:controller.c  **** /* The Omzlo USB controller
   2:controller.c  ****  * http://omzlo.com/one
   3:controller.c  ****  * Copyright (c) 2017 Alain Pannetrat
   4:controller.c  ****  * 
   5:controller.c  ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   6:controller.c  ****  * of this software and associated documentation files (the "Software"), to deal
   7:controller.c  ****  * in the Software without restriction, including without limitation the rights
   8:controller.c  ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:controller.c  ****  * copies of the Software, and to permit persons to whom the Software is
  10:controller.c  ****  * furnished to do so, subject to the following conditions:
  11:controller.c  ****  * 
  12:controller.c  ****  * The above copyright notice and this permission notice shall be included in
  13:controller.c  ****  * all copies or substantial portions of the Software.
  14:controller.c  ****  * 
  15:controller.c  ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:controller.c  ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:controller.c  ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:controller.c  ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:controller.c  ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:controller.c  ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:controller.c  ****  * THE SOFTWARE.
  22:controller.c  ****  */
  23:controller.c  **** 
  24:controller.c  **** #include <avr/io.h>
  25:controller.c  **** #include <avr/pgmspace.h>
  26:controller.c  **** #include <stdint.h>
  27:controller.c  **** #include <util/delay.h>
  28:controller.c  **** #include "usb_serial.h"
  29:controller.c  **** #include "mcp2515.h"
  30:controller.c  **** #include <avr/wdt.h>
  31:controller.c  **** 
  32:controller.c  **** #define LED_CONFIG	(DDRD |= (1<<6))
  33:controller.c  **** #define LED_ON		(PORTD |= (1<<6))
  34:controller.c  **** #define LED_OFF		(PORTD &= ~(1<<6))
  35:controller.c  **** #define CPU_PRESCALE(n) (CLKPR = 0x80, CLKPR = (n))
  36:controller.c  **** 
  37:controller.c  **** #define R_OK 0
  38:controller.c  **** #define R_ERROR (-1)
  39:controller.c  **** 
  40:controller.c  **** #define CAN_EFF_FLAG 0x80 /* Extended frame*/
  41:controller.c  **** #define CAN_RTR_FLAG 0x40 /* remote transmission request */
  42:controller.c  **** #define CAN_ERR_FLAG 0x20 /* error message frame */
  43:controller.c  **** #define CAN_CTRL_FLAG 0xE0 /* control message frame */
  44:controller.c  **** 
  45:controller.c  **** #define CAN_P_H0        0
  46:controller.c  **** #define CAN_P_H1        1
  47:controller.c  **** #define CAN_P_H2        2
  48:controller.c  **** #define CAN_P_H3        3
  49:controller.c  **** #define CAN_P_DLC       4
  50:controller.c  **** #define CAN_P_D0        5
  51:controller.c  **** #define CAN_P_D1        6
  52:controller.c  **** #define CAN_P_D2        7
  53:controller.c  **** #define CAN_P_D3        8
  54:controller.c  **** #define CAN_P_D4        9
  55:controller.c  **** #define CAN_P_D5        10
  56:controller.c  **** #define CAN_P_D6        11
  57:controller.c  **** #define CAN_P_D7        12
  58:controller.c  **** 
  59:controller.c  **** #define FN_INT_CONFIG()         (DDRD &= ~(1<<PD0))
  60:controller.c  **** #define FN_INT_IS_SET()         (bit_is_clear(PIND,PD0))
  61:controller.c  **** 
  62:controller.c  **** #ifdef OLD_PINOUT
  63:controller.c  ****   #define FN_IN_CONFIG()          (DDRD |= (1<<3))
  64:controller.c  ****   #define FN_IN_SET()             (PORTD |= (1<<3))
  65:controller.c  ****   #define FN_IN_CLEAR()           (PORTD &= ~(1<<3))
  66:controller.c  **** #else
  67:controller.c  ****   #define FN_IN_CONFIG()          (DDRE |= (1<<6))
  68:controller.c  ****   #define FN_IN_SET()             (PORTE |= (1<<6))
  69:controller.c  ****   #define FN_IN_CLEAR()           (PORTE &= ~(1<<6))
  70:controller.c  **** #endif
  71:controller.c  **** 
  72:controller.c  **** #define FN_LED_ORANGE_CONFIG()  (DDRB |= (1<<7))
  73:controller.c  **** #define FN_LED_ORANGE_SET()     (PORTB |= (1<<7))
  74:controller.c  **** #define FN_LED_ORANGE_CLEAR()   (PORTB &= ~(1<<7))
  75:controller.c  **** 
  76:controller.c  **** #define FN_LED_RED_CONFIG()     (DDRB |= (1<<6))
  77:controller.c  **** #define FN_LED_RED_SET()        (PORTB |= (1<<6))
  78:controller.c  **** #define FN_LED_RED_CLEAR()      (PORTB &= ~(1<<6))
  79:controller.c  **** 
  80:controller.c  **** #define FN_DEN_CONFIG()         (DDRB |= (1<<5))
  81:controller.c  **** #define FN_DEN_SET()            (PORTB |= (1<<5))
  82:controller.c  **** #define FN_DEN_CLEAR()          (PORTB &= ~(1<<5))
  83:controller.c  **** 
  84:controller.c  **** #define FN_CAN_R_CONFIG()         (DDRB |= (1<<4))
  85:controller.c  **** #define FN_CAN_R_SET()            (PORTB |= (1<<4))
  86:controller.c  **** #define FN_CAN_R_CLEAR()          (PORTB &= ~(1<<4))
  87:controller.c  **** 
  88:controller.c  **** 
  89:controller.c  **** 
  90:controller.c  **** #define CHANNEL_SENSE   0x00
  91:controller.c  **** #define CHANNEL_VIN     0x01
  92:controller.c  **** #define CHANNEL_VREF    0x1E 
  93:controller.c  **** 
  94:controller.c  **** 
  95:controller.c  **** #define POWER_FLAGS_SUPPLY 0x01
  96:controller.c  **** #define POWER_FLAGS_SENSE  0x02
  97:controller.c  **** #define POWER_FLAGS_FAULT  0x04
  98:controller.c  **** 
  99:controller.c  **** uint8_t get_byte(uint8_t *dst)
 100:controller.c  **** {
 101:controller.c  **** 	int16_t r = usb_serial_getchar();
 102:controller.c  ****     
 103:controller.c  ****     if (r == -1) 
 104:controller.c  ****         return R_ERROR;
 105:controller.c  ****     
 106:controller.c  ****     *dst = r&0xFF;
 107:controller.c  ****     return R_OK;
 108:controller.c  **** }
 109:controller.c  **** 
 110:controller.c  **** void put_byte(int8_t byte)
 111:controller.c  **** {
 112:controller.c  ****     usb_serial_putchar_nowait(byte);
 113:controller.c  **** }
 114:controller.c  **** 
 115:controller.c  **** void put_byte_n(const uint8_t *data, uint8_t len)
 116:controller.c  **** {
 117:controller.c  ****     //int i;
 118:controller.c  ****     //for (i=0;i<len;i++) usb_serial_putchar(data[i]);
 119:controller.c  ****     usb_serial_write(data,len);
 120:controller.c  **** }
 121:controller.c  **** 
 122:controller.c  **** int8_t can_recv(uint8_t *dest)
 123:controller.c  **** {
 124:controller.c  ****     uint8_t val = mcp2515_rx_status();
 125:controller.c  ****     uint8_t base,clear,i;
 126:controller.c  ****     uint8_t a0,a1,a2,a3,dlc;
 127:controller.c  **** 
 128:controller.c  ****     if (bit_is_set(val, RX_STATUS_RXB0_READY))
 129:controller.c  ****     {
 130:controller.c  ****         base = RXB0;
 131:controller.c  ****         clear = RX0IF;
 132:controller.c  ****     } 
 133:controller.c  ****     else if (bit_is_set(val, RX_STATUS_RXB1_READY))
 134:controller.c  ****     {
 135:controller.c  ****         base = RXB1;
 136:controller.c  ****         clear = RX1IF;
 137:controller.c  ****     }
 138:controller.c  ****     else 
 139:controller.c  ****     {
 140:controller.c  ****         return R_ERROR;
 141:controller.c  ****     }
 142:controller.c  **** 
 143:controller.c  ****     mcp2515_slave_select();
 144:controller.c  ****     spi_transmit(MCP_READ);
 145:controller.c  ****     spi_transmit(base+xSIDH);
 146:controller.c  ****     a0 = spi_transmit(0);
 147:controller.c  ****     a1 = spi_transmit(0);
 148:controller.c  ****     a2 = spi_transmit(0);
 149:controller.c  ****     a3 = spi_transmit(0);
 150:controller.c  ****     dlc= spi_transmit(0);
 151:controller.c  ****     for (i=5;i<13;i++)
 152:controller.c  ****         dest[i] = spi_transmit(0);
 153:controller.c  ****     mcp2515_slave_release();
 154:controller.c  ****  
 155:controller.c  ****     mcp2515_register_write_bit(CANINTF,clear,0);
 156:controller.c  **** 
 157:controller.c  ****     if ((a1&0x08)!=0)
 158:controller.c  ****     {   // extended frame
 159:controller.c  ****         dest[0] = (a0 >> 3) | CAN_EFF_FLAG;
 160:controller.c  ****         dest[1] = (a0 << 5) | ((a1&0xE0)>>3) | (a1&0x03);
 161:controller.c  ****         dest[2] = a2;
 162:controller.c  ****         dest[3] = a3;
 163:controller.c  ****     }
 164:controller.c  ****     else // standard frame
 165:controller.c  ****     {
 166:controller.c  ****         dest[0] = 0;
 167:controller.c  ****         dest[1] = 0;
 168:controller.c  ****         dest[2] = (a0>>5);
 169:controller.c  ****         dest[3] = (a0<<3) | (a1>>5);
 170:controller.c  ****     }
 171:controller.c  ****     // the RTR_FLAG is in the dlc byte, so we just mask it out and add it
 172:controller.c  ****     dest[0] |= (dlc & CAN_RTR_FLAG);
 173:controller.c  ****     dest[4] = dlc&0x0F;
 174:controller.c  ****     //if (dest[4]>8) dest[4]=8;
 175:controller.c  **** 
 176:controller.c  ****     return R_OK;
 177:controller.c  **** }
 178:controller.c  **** 
 179:controller.c  **** int8_t can_send(const uint8_t *src)
 180:controller.c  **** {
 181:controller.c  ****     uint8_t val,base,i,a0,a1,a2,a3,dlc;
 182:controller.c  **** 
 183:controller.c  ****     val = mcp2515_status();
 184:controller.c  **** 
 185:controller.c  ****     if (bit_is_clear(val,STATUS_TXB0CNTRL_TXREQ))
 186:controller.c  ****     {
 187:controller.c  ****         base = TXB0;
 188:controller.c  ****     } 
 189:controller.c  ****     else if (bit_is_clear(val, STATUS_TXB1CNTRL_TXREQ))
 190:controller.c  ****     {
 191:controller.c  ****         base = TXB1;
 192:controller.c  ****     }
 193:controller.c  ****     /*
 194:controller.c  ****        else if (bit_is_clear(val, STATUS_TXB2CNTRL_TXREQ))
 195:controller.c  ****        {
 196:controller.c  ****        base = TXB2;
 197:controller.c  ****        }
 198:controller.c  ****        */
 199:controller.c  ****     else
 200:controller.c  ****     {    
 201:controller.c  ****         return R_ERROR;
 202:controller.c  ****     }
 203:controller.c  **** 
 204:controller.c  ****     if ((*src&CAN_EFF_FLAG)!=0)
 205:controller.c  ****     {   // extended frame
 206:controller.c  ****         a0 = (src[0]<<3) | (src[1]>>5);
 207:controller.c  ****         a1 = ((src[1]&0x1C)<<3) | 0x08 | (src[1]&0x03);
 208:controller.c  ****         a2 = src[2];
 209:controller.c  ****         a3 = src[3];
 210:controller.c  ****     }
 211:controller.c  ****     else
 212:controller.c  ****     {   // standard frame
 213:controller.c  ****         a0 = (src[2]<<3) | (src[3]>>5);
 214:controller.c  ****         a1 = src[3] << 5;
 215:controller.c  ****         a2 = 0;
 216:controller.c  ****         a3 = 0;
 217:controller.c  ****     }
 218:controller.c  ****     dlc = (src[0]&CAN_RTR_FLAG) | (src[4]&0x0F);
 219:controller.c  ****     
 220:controller.c  ****     src += 5;
 221:controller.c  **** 
 222:controller.c  ****     mcp2515_slave_select();
 223:controller.c  ****     spi_transmit(MCP_WRITE);
 224:controller.c  ****     spi_transmit(base+xSIDH);
 225:controller.c  ****     spi_transmit(a0);
 226:controller.c  ****     spi_transmit(a1);
 227:controller.c  ****     spi_transmit(a2);
 228:controller.c  ****     spi_transmit(a3);
 229:controller.c  ****     spi_transmit(dlc);
 230:controller.c  ****     for (i=0;i<8;i++)
 231:controller.c  ****         spi_transmit(*src++);
 232:controller.c  ****     mcp2515_slave_release();
 233:controller.c  **** 
 234:controller.c  ****     mcp2515_register_write_bit(base+xCTRL,TXREQ,1);
 235:controller.c  **** 
 236:controller.c  ****     return R_OK;
 237:controller.c  **** }
 238:controller.c  **** 
 239:controller.c  **** int8_t can_init(void)
 240:controller.c  **** {
 241:controller.c  ****     spi_master_init();
 242:controller.c  **** 
 243:controller.c  ****     mcp2515_slave_setup();
 244:controller.c  **** 
 245:controller.c  ****     mcp2515_slave_select();
 246:controller.c  ****     spi_transmit(MCP_RESET);
 247:controller.c  ****     mcp2515_slave_release();
 248:controller.c  **** 
 249:controller.c  ****     _delay_ms(100);
 250:controller.c  **** 
 251:controller.c  ****     if ((mcp2515_register_read(CANSTAT)&0xE0)!=0x80) return R_ERROR;    // check if we are in confi
 252:controller.c  ****    
 253:controller.c  ****     mcp2515_register_write(CNF1,0x03);
 254:controller.c  ****     mcp2515_register_write(CNF2,0xF0);
 255:controller.c  ****     mcp2515_register_write(CNF3,0x86);
 256:controller.c  **** 
 257:controller.c  ****     // set RXB0CTRL.BUKT to 1 for automatic overflow
 258:controller.c  ****     mcp2515_register_write(RXB0+xCTRL, (1<<RXM0) | (1<<RXM1) | (1<<BUKT)); // Buffer 0: receive eve
 259:controller.c  ****     mcp2515_register_write(RXB1+xCTRL, (1<<RXM0) | (1<<RXM1));             // Buffer 1: receive eve
 260:controller.c  **** 
 261:controller.c  ****     // set CANINTE.RX0IE to 1, interrupt enable for RX0
 262:controller.c  ****     mcp2515_register_write_bit(CANINTE, RX0IE, 1);
 263:controller.c  **** 
 264:controller.c  ****     // set CANINTE.RX1IE to 1, interrupt enable for RX1
 265:controller.c  ****     mcp2515_register_write_bit(CANINTE, RX1IE, 1);
 266:controller.c  **** 
 267:controller.c  ****     mcp2515_register_write(CANCTRL,0x00);
 268:controller.c  **** 
 269:controller.c  ****     _delay_ms(10);
 270:controller.c  **** 
 271:controller.c  ****     if ((mcp2515_register_read(CANSTAT)&0xE0)!=0x00) return R_ERROR;
 272:controller.c  **** 
 273:controller.c  ****     return R_OK; 
 274:controller.c  **** }
 275:controller.c  **** 
 276:controller.c  **** uint16_t adc_read(uint8_t channel)
 277:controller.c  **** {
 278:controller.c  ****     uint8_t low;
 279:controller.c  **** 
 280:controller.c  ****     ADMUX = (1 << REFS0)|(channel&0x1F); // set channel in low 5 bits
 281:controller.c  ****     //ADCSRA = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0) | (1<<ADEN);                 // start rea
 282:controller.c  ****     ADCSRB = (1<<ADHSM) | (channel & 0x20);
 283:controller.c  ****     //if (channel==CHANNEL_VREF)
 284:controller.c  ****         _delay_ms(1);
 285:controller.c  ****     ADCSRA = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0) | (1<<ADEN) | (1<<ADSC);                 //
 286:controller.c  ****     while (bit_is_set(ADCSRA,ADSC));          // wait until done
 287:controller.c  ****     low = ADCL;
 288:controller.c  ****     //result |= ((uint16_t)(ADCH))<<8;
 289:controller.c  ****     return (ADCH<<8)|low;             // return result
 290:controller.c  **** }
 291:controller.c  **** 
 292:controller.c  **** static int power_up(void)
 293:controller.c  **** {
  15               		.loc 1 293 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 294:controller.c  ****     FN_LED_RED_SET();
  21               		.loc 1 294 0
  22 0000 2E9A      		sbi 0x5,6
 295:controller.c  ****     FN_IN_SET();    // Enable switch
  23               		.loc 1 295 0
  24 0002 769A      		sbi 0xe,6
 296:controller.c  ****         
 297:controller.c  ****     return 0;
 298:controller.c  **** }
  25               		.loc 1 298 0
  26 0004 80E0      		ldi r24,0
  27 0006 90E0      		ldi r25,0
  28 0008 0895      		ret
  29               		.cfi_endproc
  30               	.LFE16:
  32               		.section	.text.power_down,"ax",@progbits
  34               	power_down:
  35               	.LFB17:
 299:controller.c  **** 
 300:controller.c  **** static int power_down(void)
 301:controller.c  **** {
  36               		.loc 1 301 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
 302:controller.c  ****     FN_LED_RED_CLEAR();
  42               		.loc 1 302 0
  43 0000 2E98      		cbi 0x5,6
 303:controller.c  ****     FN_IN_CLEAR();  // Disable switch
  44               		.loc 1 303 0
  45 0002 7698      		cbi 0xe,6
 304:controller.c  ****     
 305:controller.c  ****     return 0;
 306:controller.c  **** }
  46               		.loc 1 306 0
  47 0004 80E0      		ldi r24,0
  48 0006 90E0      		ldi r25,0
  49 0008 0895      		ret
  50               		.cfi_endproc
  51               	.LFE17:
  53               		.section	.text.get_byte,"ax",@progbits
  54               	.global	get_byte
  56               	get_byte:
  57               	.LFB9:
 100:controller.c  **** 	int16_t r = usb_serial_getchar();
  58               		.loc 1 100 0
  59               		.cfi_startproc
  60               	.LVL0:
  61 0000 CF93      		push r28
  62               	.LCFI0:
  63               		.cfi_def_cfa_offset 3
  64               		.cfi_offset 28, -2
  65 0002 DF93      		push r29
  66               	.LCFI1:
  67               		.cfi_def_cfa_offset 4
  68               		.cfi_offset 29, -3
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 2 */
  72               	.L__stack_usage = 2
  73 0004 EC01      		movw r28,r24
 101:controller.c  ****     
  74               		.loc 1 101 0
  75 0006 0E94 0000 		call usb_serial_getchar
  76               	.LVL1:
 103:controller.c  ****         return R_ERROR;
  77               		.loc 1 103 0
  78 000a 8F3F      		cpi r24,-1
  79 000c 2FEF      		ldi r18,-1
  80 000e 9207      		cpc r25,r18
  81 0010 01F0      		breq .L5
 106:controller.c  ****     return R_OK;
  82               		.loc 1 106 0
  83 0012 8883      		st Y,r24
 107:controller.c  **** }
  84               		.loc 1 107 0
  85 0014 80E0      		ldi r24,0
  86               	.LVL2:
  87 0016 00C0      		rjmp .L4
  88               	.LVL3:
  89               	.L5:
 104:controller.c  ****     
  90               		.loc 1 104 0
  91 0018 8FEF      		ldi r24,lo8(-1)
  92               	.LVL4:
  93               	.L4:
  94               	/* epilogue start */
 108:controller.c  **** 
  95               		.loc 1 108 0
  96 001a DF91      		pop r29
  97 001c CF91      		pop r28
  98               	.LVL5:
  99 001e 0895      		ret
 100               		.cfi_endproc
 101               	.LFE9:
 103               		.section	.text.put_byte,"ax",@progbits
 104               	.global	put_byte
 106               	put_byte:
 107               	.LFB10:
 111:controller.c  ****     usb_serial_putchar_nowait(byte);
 108               		.loc 1 111 0
 109               		.cfi_startproc
 110               	.LVL6:
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 0 */
 114               	.L__stack_usage = 0
 112:controller.c  **** }
 115               		.loc 1 112 0
 116 0000 0C94 0000 		jmp usb_serial_putchar_nowait
 117               	.LVL7:
 118               		.cfi_endproc
 119               	.LFE10:
 121               		.section	.text.put_byte_n,"ax",@progbits
 122               	.global	put_byte_n
 124               	put_byte_n:
 125               	.LFB11:
 116:controller.c  ****     //int i;
 126               		.loc 1 116 0
 127               		.cfi_startproc
 128               	.LVL8:
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 0 */
 132               	.L__stack_usage = 0
 119:controller.c  **** }
 133               		.loc 1 119 0
 134 0000 70E0      		ldi r23,0
 135 0002 0C94 0000 		jmp usb_serial_write
 136               	.LVL9:
 137               		.cfi_endproc
 138               	.LFE11:
 140               		.section	.text.can_recv,"ax",@progbits
 141               	.global	can_recv
 143               	can_recv:
 144               	.LFB12:
 123:controller.c  ****     uint8_t val = mcp2515_rx_status();
 145               		.loc 1 123 0
 146               		.cfi_startproc
 147               	.LVL10:
 148 0000 6F92      		push r6
 149               	.LCFI2:
 150               		.cfi_def_cfa_offset 3
 151               		.cfi_offset 6, -2
 152 0002 7F92      		push r7
 153               	.LCFI3:
 154               		.cfi_def_cfa_offset 4
 155               		.cfi_offset 7, -3
 156 0004 8F92      		push r8
 157               	.LCFI4:
 158               		.cfi_def_cfa_offset 5
 159               		.cfi_offset 8, -4
 160 0006 9F92      		push r9
 161               	.LCFI5:
 162               		.cfi_def_cfa_offset 6
 163               		.cfi_offset 9, -5
 164 0008 AF92      		push r10
 165               	.LCFI6:
 166               		.cfi_def_cfa_offset 7
 167               		.cfi_offset 10, -6
 168 000a BF92      		push r11
 169               	.LCFI7:
 170               		.cfi_def_cfa_offset 8
 171               		.cfi_offset 11, -7
 172 000c CF92      		push r12
 173               	.LCFI8:
 174               		.cfi_def_cfa_offset 9
 175               		.cfi_offset 12, -8
 176 000e DF92      		push r13
 177               	.LCFI9:
 178               		.cfi_def_cfa_offset 10
 179               		.cfi_offset 13, -9
 180 0010 EF92      		push r14
 181               	.LCFI10:
 182               		.cfi_def_cfa_offset 11
 183               		.cfi_offset 14, -10
 184 0012 FF92      		push r15
 185               	.LCFI11:
 186               		.cfi_def_cfa_offset 12
 187               		.cfi_offset 15, -11
 188 0014 0F93      		push r16
 189               	.LCFI12:
 190               		.cfi_def_cfa_offset 13
 191               		.cfi_offset 16, -12
 192 0016 1F93      		push r17
 193               	.LCFI13:
 194               		.cfi_def_cfa_offset 14
 195               		.cfi_offset 17, -13
 196 0018 CF93      		push r28
 197               	.LCFI14:
 198               		.cfi_def_cfa_offset 15
 199               		.cfi_offset 28, -14
 200 001a DF93      		push r29
 201               	.LCFI15:
 202               		.cfi_def_cfa_offset 16
 203               		.cfi_offset 29, -15
 204 001c 00D0      		rcall .
 205               	.LCFI16:
 206               		.cfi_def_cfa_offset 18
 207 001e CDB7      		in r28,__SP_L__
 208 0020 DEB7      		in r29,__SP_H__
 209               	.LCFI17:
 210               		.cfi_def_cfa_register 28
 211               	/* prologue: function */
 212               	/* frame size = 2 */
 213               	/* stack size = 16 */
 214               	.L__stack_usage = 16
 215 0022 8C01      		movw r16,r24
 124:controller.c  ****     uint8_t base,clear,i;
 216               		.loc 1 124 0
 217 0024 0E94 0000 		call mcp2515_rx_status
 218               	.LVL11:
 219 0028 8983      		std Y+1,r24
 128:controller.c  ****     {
 220               		.loc 1 128 0
 221 002a 8981      		ldd r24,Y+1
 222 002c 86FD      		sbrc r24,6
 223 002e 00C0      		rjmp .L15
 133:controller.c  ****     {
 224               		.loc 1 133 0
 225 0030 8981      		ldd r24,Y+1
 226 0032 87FF      		sbrs r24,7
 227 0034 00C0      		rjmp .L16
 136:controller.c  ****     }
 228               		.loc 1 136 0
 229 0036 AA24      		clr r10
 230 0038 A394      		inc r10
 135:controller.c  ****         clear = RX1IF;
 231               		.loc 1 135 0
 232 003a 90E7      		ldi r25,lo8(112)
 233 003c 00C0      		rjmp .L10
 234               	.L15:
 131:controller.c  ****     } 
 235               		.loc 1 131 0
 236 003e A12C      		mov r10,__zero_reg__
 130:controller.c  ****         clear = RX0IF;
 237               		.loc 1 130 0
 238 0040 90E6      		ldi r25,lo8(96)
 239               	.L10:
 240               	.LVL12:
 143:controller.c  ****     spi_transmit(MCP_READ);
 241               		.loc 1 143 0
 242 0042 2898      		cbi 0x5,0
 144:controller.c  ****     spi_transmit(base+xSIDH);
 243               		.loc 1 144 0
 244 0044 83E0      		ldi r24,lo8(3)
 245 0046 9A83      		std Y+2,r25
 246 0048 0E94 0000 		call spi_transmit
 247               	.LVL13:
 145:controller.c  ****     a0 = spi_transmit(0);
 248               		.loc 1 145 0
 249 004c 9A81      		ldd r25,Y+2
 250 004e 81E0      		ldi r24,lo8(1)
 251 0050 890F      		add r24,r25
 252 0052 0E94 0000 		call spi_transmit
 253               	.LVL14:
 146:controller.c  ****     a1 = spi_transmit(0);
 254               		.loc 1 146 0
 255 0056 80E0      		ldi r24,0
 256 0058 0E94 0000 		call spi_transmit
 257               	.LVL15:
 258 005c E82E      		mov r14,r24
 259               	.LVL16:
 147:controller.c  ****     a2 = spi_transmit(0);
 260               		.loc 1 147 0
 261 005e 80E0      		ldi r24,0
 262 0060 0E94 0000 		call spi_transmit
 263               	.LVL17:
 264 0064 F82E      		mov r15,r24
 265               	.LVL18:
 148:controller.c  ****     a3 = spi_transmit(0);
 266               		.loc 1 148 0
 267 0066 80E0      		ldi r24,0
 268 0068 0E94 0000 		call spi_transmit
 269               	.LVL19:
 270 006c B82E      		mov r11,r24
 271               	.LVL20:
 149:controller.c  ****     dlc= spi_transmit(0);
 272               		.loc 1 149 0
 273 006e 80E0      		ldi r24,0
 274 0070 0E94 0000 		call spi_transmit
 275               	.LVL21:
 276 0074 C82E      		mov r12,r24
 277               	.LVL22:
 150:controller.c  ****     for (i=5;i<13;i++)
 278               		.loc 1 150 0
 279 0076 80E0      		ldi r24,0
 280 0078 0E94 0000 		call spi_transmit
 281               	.LVL23:
 282 007c D82E      		mov r13,r24
 283               	.LVL24:
 284 007e 4801      		movw r8,r16
 285 0080 85E0      		ldi r24,5
 286 0082 880E      		add r8,r24
 287 0084 911C      		adc r9,__zero_reg__
 288 0086 3801      		movw r6,r16
 289 0088 EDE0      		ldi r30,13
 290 008a 6E0E      		add r6,r30
 291 008c 711C      		adc r7,__zero_reg__
 292               	.LVL25:
 293               	.L12:
 152:controller.c  ****     mcp2515_slave_release();
 294               		.loc 1 152 0 discriminator 3
 295 008e 80E0      		ldi r24,0
 296 0090 0E94 0000 		call spi_transmit
 297               	.LVL26:
 298 0094 F401      		movw r30,r8
 299 0096 8193      		st Z+,r24
 300 0098 4F01      		movw r8,r30
 301               	.LVL27:
 151:controller.c  ****         dest[i] = spi_transmit(0);
 302               		.loc 1 151 0 discriminator 3
 303 009a E615      		cp r30,r6
 304 009c F705      		cpc r31,r7
 305 009e 01F4      		brne .L12
 153:controller.c  ****  
 306               		.loc 1 153 0
 307 00a0 289A      		sbi 0x5,0
 155:controller.c  **** 
 308               		.loc 1 155 0
 309 00a2 40E0      		ldi r20,0
 310 00a4 6A2D      		mov r22,r10
 311 00a6 8CE2      		ldi r24,lo8(44)
 312 00a8 0E94 0000 		call mcp2515_register_write_bit
 313               	.LVL28:
 314 00ac 2E2D      		mov r18,r14
 315 00ae 30E0      		ldi r19,0
 157:controller.c  ****     {   // extended frame
 316               		.loc 1 157 0
 317 00b0 F3FE      		sbrs r15,3
 318 00b2 00C0      		rjmp .L13
 159:controller.c  ****         dest[1] = (a0 << 5) | ((a1&0xE0)>>3) | (a1&0x03);
 319               		.loc 1 159 0
 320 00b4 9E2D      		mov r25,r14
 321 00b6 9695      		lsr r25
 322 00b8 9695      		lsr r25
 323 00ba 9695      		lsr r25
 324 00bc 9068      		ori r25,lo8(-128)
 325 00be F801      		movw r30,r16
 326 00c0 9083      		st Z,r25
 160:controller.c  ****         dest[2] = a2;
 327               		.loc 1 160 0
 328 00c2 45E0      		ldi r20,5
 329               		1:
 330 00c4 220F      		lsl r18
 331 00c6 331F      		rol r19
 332 00c8 4A95      		dec r20
 333 00ca 01F4      		brne 1b
 334 00cc 8F2D      		mov r24,r15
 335 00ce 8370      		andi r24,lo8(3)
 336 00d0 282B      		or r18,r24
 337 00d2 8F2D      		mov r24,r15
 338 00d4 807E      		andi r24,lo8(-32)
 339 00d6 F82E      		mov r15,r24
 340               	.LVL29:
 341 00d8 F694      		lsr r15
 342 00da F694      		lsr r15
 343 00dc F694      		lsr r15
 344 00de 2F29      		or r18,r15
 345 00e0 2183      		std Z+1,r18
 161:controller.c  ****         dest[3] = a3;
 346               		.loc 1 161 0
 347 00e2 B282      		std Z+2,r11
 162:controller.c  ****     }
 348               		.loc 1 162 0
 349 00e4 C382      		std Z+3,r12
 350 00e6 00C0      		rjmp .L14
 351               	.LVL30:
 352               	.L13:
 166:controller.c  ****         dest[1] = 0;
 353               		.loc 1 166 0
 354 00e8 F801      		movw r30,r16
 355 00ea 1082      		st Z,__zero_reg__
 167:controller.c  ****         dest[2] = (a0>>5);
 356               		.loc 1 167 0
 357 00ec 1182      		std Z+1,__zero_reg__
 168:controller.c  ****         dest[3] = (a0<<3) | (a1>>5);
 358               		.loc 1 168 0
 359 00ee E294      		swap r14
 360               	.LVL31:
 361 00f0 E694      		lsr r14
 362 00f2 87E0      		ldi r24,lo8(7)
 363 00f4 E822      		and r14,r24
 364 00f6 E282      		std Z+2,r14
 169:controller.c  ****     }
 365               		.loc 1 169 0
 366 00f8 93E0      		ldi r25,3
 367               		1:
 368 00fa 220F      		lsl r18
 369 00fc 331F      		rol r19
 370 00fe 9A95      		dec r25
 371 0100 01F4      		brne 1b
 372               	.LVL32:
 373 0102 F294      		swap r15
 374               	.LVL33:
 375 0104 F694      		lsr r15
 376 0106 37E0      		ldi r19,lo8(7)
 377 0108 F322      		and r15,r19
 378 010a 2F29      		or r18,r15
 379 010c 2383      		std Z+3,r18
 380               	.L14:
 172:controller.c  ****     dest[4] = dlc&0x0F;
 381               		.loc 1 172 0
 382 010e 8D2D      		mov r24,r13
 383 0110 8074      		andi r24,lo8(64)
 384 0112 F801      		movw r30,r16
 385 0114 9081      		ld r25,Z
 386 0116 892B      		or r24,r25
 387 0118 8083      		st Z,r24
 173:controller.c  ****     //if (dest[4]>8) dest[4]=8;
 388               		.loc 1 173 0
 389 011a 8D2D      		mov r24,r13
 390 011c 8F70      		andi r24,lo8(15)
 391 011e 8483      		std Z+4,r24
 176:controller.c  **** }
 392               		.loc 1 176 0
 393 0120 80E0      		ldi r24,0
 394 0122 00C0      		rjmp .L11
 395               	.LVL34:
 396               	.L16:
 140:controller.c  ****     }
 397               		.loc 1 140 0
 398 0124 8FEF      		ldi r24,lo8(-1)
 399               	.L11:
 400               	/* epilogue start */
 177:controller.c  **** 
 401               		.loc 1 177 0
 402 0126 0F90      		pop __tmp_reg__
 403 0128 0F90      		pop __tmp_reg__
 404 012a DF91      		pop r29
 405 012c CF91      		pop r28
 406 012e 1F91      		pop r17
 407 0130 0F91      		pop r16
 408               	.LVL35:
 409 0132 FF90      		pop r15
 410 0134 EF90      		pop r14
 411 0136 DF90      		pop r13
 412 0138 CF90      		pop r12
 413 013a BF90      		pop r11
 414 013c AF90      		pop r10
 415 013e 9F90      		pop r9
 416 0140 8F90      		pop r8
 417 0142 7F90      		pop r7
 418 0144 6F90      		pop r6
 419 0146 0895      		ret
 420               		.cfi_endproc
 421               	.LFE12:
 423               		.section	.text.can_send,"ax",@progbits
 424               	.global	can_send
 426               	can_send:
 427               	.LFB13:
 180:controller.c  ****     uint8_t val,base,i,a0,a1,a2,a3,dlc;
 428               		.loc 1 180 0
 429               		.cfi_startproc
 430               	.LVL36:
 431 0000 AF92      		push r10
 432               	.LCFI18:
 433               		.cfi_def_cfa_offset 3
 434               		.cfi_offset 10, -2
 435 0002 BF92      		push r11
 436               	.LCFI19:
 437               		.cfi_def_cfa_offset 4
 438               		.cfi_offset 11, -3
 439 0004 CF92      		push r12
 440               	.LCFI20:
 441               		.cfi_def_cfa_offset 5
 442               		.cfi_offset 12, -4
 443 0006 DF92      		push r13
 444               	.LCFI21:
 445               		.cfi_def_cfa_offset 6
 446               		.cfi_offset 13, -5
 447 0008 EF92      		push r14
 448               	.LCFI22:
 449               		.cfi_def_cfa_offset 7
 450               		.cfi_offset 14, -6
 451 000a FF92      		push r15
 452               	.LCFI23:
 453               		.cfi_def_cfa_offset 8
 454               		.cfi_offset 15, -7
 455 000c 0F93      		push r16
 456               	.LCFI24:
 457               		.cfi_def_cfa_offset 9
 458               		.cfi_offset 16, -8
 459 000e 1F93      		push r17
 460               	.LCFI25:
 461               		.cfi_def_cfa_offset 10
 462               		.cfi_offset 17, -9
 463 0010 CF93      		push r28
 464               	.LCFI26:
 465               		.cfi_def_cfa_offset 11
 466               		.cfi_offset 28, -10
 467 0012 DF93      		push r29
 468               	.LCFI27:
 469               		.cfi_def_cfa_offset 12
 470               		.cfi_offset 29, -11
 471 0014 1F92      		push __zero_reg__
 472               	.LCFI28:
 473               		.cfi_def_cfa_offset 13
 474 0016 CDB7      		in r28,__SP_L__
 475 0018 DEB7      		in r29,__SP_H__
 476               	.LCFI29:
 477               		.cfi_def_cfa_register 28
 478               	/* prologue: function */
 479               	/* frame size = 1 */
 480               	/* stack size = 11 */
 481               	.L__stack_usage = 11
 482 001a 7C01      		movw r14,r24
 183:controller.c  **** 
 483               		.loc 1 183 0
 484 001c 0E94 0000 		call mcp2515_status
 485               	.LVL37:
 486 0020 8983      		std Y+1,r24
 185:controller.c  ****     {
 487               		.loc 1 185 0
 488 0022 8981      		ldd r24,Y+1
 489 0024 82FF      		sbrs r24,2
 490 0026 00C0      		rjmp .L24
 189:controller.c  ****     {
 491               		.loc 1 189 0
 492 0028 8981      		ldd r24,Y+1
 493 002a 84FD      		sbrc r24,4
 494 002c 00C0      		rjmp .L25
 191:controller.c  ****     }
 495               		.loc 1 191 0
 496 002e 00E4      		ldi r16,lo8(64)
 497 0030 00C0      		rjmp .L19
 498               	.L24:
 187:controller.c  ****     } 
 499               		.loc 1 187 0
 500 0032 00E3      		ldi r16,lo8(48)
 501               	.L19:
 502               	.LVL38:
 204:controller.c  ****     {   // extended frame
 503               		.loc 1 204 0
 504 0034 F701      		movw r30,r14
 505 0036 6081      		ld r22,Z
 506 0038 A280      		ldd r10,Z+2
 507 003a 7381      		ldd r23,Z+3
 508 003c 67FF      		sbrs r22,7
 509 003e 00C0      		rjmp .L21
 206:controller.c  ****         a1 = ((src[1]&0x1C)<<3) | 0x08 | (src[1]&0x03);
 510               		.loc 1 206 0
 511 0040 9181      		ldd r25,Z+1
 512 0042 F8E0      		ldi r31,lo8(8)
 513 0044 6F9F      		mul r22,r31
 514 0046 A001      		movw r20,r0
 515 0048 1124      		clr __zero_reg__
 516 004a 292F      		mov r18,r25
 517 004c 2295      		swap r18
 518 004e 2695      		lsr r18
 519 0050 2770      		andi r18,lo8(7)
 520 0052 D22E      		mov r13,r18
 521 0054 D42A      		or r13,r20
 522               	.LVL39:
 207:controller.c  ****         a2 = src[2];
 523               		.loc 1 207 0
 524 0056 192F      		mov r17,r25
 525 0058 1370      		andi r17,lo8(3)
 526 005a 1860      		ori r17,lo8(8)
 527 005c 9C71      		andi r25,lo8(28)
 528 005e 88E0      		ldi r24,lo8(8)
 529 0060 989F      		mul r25,r24
 530 0062 9001      		movw r18,r0
 531 0064 1124      		clr __zero_reg__
 532 0066 122B      		or r17,r18
 533               	.LVL40:
 209:controller.c  ****     }
 534               		.loc 1 209 0
 535 0068 B72E      		mov r11,r23
 536               	.LVL41:
 537 006a 00C0      		rjmp .L22
 538               	.LVL42:
 539               	.L21:
 213:controller.c  ****         a1 = src[3] << 5;
 540               		.loc 1 213 0
 541 006c E8E0      		ldi r30,lo8(8)
 542 006e AE9E      		mul r10,r30
 543 0070 9001      		movw r18,r0
 544 0072 1124      		clr __zero_reg__
 545 0074 472F      		mov r20,r23
 546 0076 4295      		swap r20
 547 0078 4695      		lsr r20
 548 007a 4770      		andi r20,lo8(7)
 549 007c D42E      		mov r13,r20
 550 007e D22A      		or r13,r18
 551               	.LVL43:
 214:controller.c  ****         a2 = 0;
 552               		.loc 1 214 0
 553 0080 172F      		mov r17,r23
 554 0082 1295      		swap r17
 555 0084 110F      		lsl r17
 556 0086 107E      		andi r17,lo8(-32)
 557               	.LVL44:
 216:controller.c  ****     }
 558               		.loc 1 216 0
 559 0088 B12C      		mov r11,__zero_reg__
 215:controller.c  ****         a3 = 0;
 560               		.loc 1 215 0
 561 008a A12C      		mov r10,__zero_reg__
 562               	.LVL45:
 563               	.L22:
 218:controller.c  ****     
 564               		.loc 1 218 0
 565 008c F701      		movw r30,r14
 566 008e 8481      		ldd r24,Z+4
 567 0090 8F70      		andi r24,lo8(15)
 568 0092 6074      		andi r22,lo8(64)
 569 0094 C82E      		mov r12,r24
 570 0096 C62A      		or r12,r22
 571               	.LVL46:
 222:controller.c  ****     spi_transmit(MCP_WRITE);
 572               		.loc 1 222 0
 573 0098 2898      		cbi 0x5,0
 223:controller.c  ****     spi_transmit(base+xSIDH);
 574               		.loc 1 223 0
 575 009a 82E0      		ldi r24,lo8(2)
 576 009c 0E94 0000 		call spi_transmit
 577               	.LVL47:
 224:controller.c  ****     spi_transmit(a0);
 578               		.loc 1 224 0
 579 00a0 81E0      		ldi r24,lo8(1)
 580 00a2 800F      		add r24,r16
 581 00a4 0E94 0000 		call spi_transmit
 582               	.LVL48:
 225:controller.c  ****     spi_transmit(a1);
 583               		.loc 1 225 0
 584 00a8 8D2D      		mov r24,r13
 585 00aa 0E94 0000 		call spi_transmit
 586               	.LVL49:
 226:controller.c  ****     spi_transmit(a2);
 587               		.loc 1 226 0
 588 00ae 812F      		mov r24,r17
 589 00b0 0E94 0000 		call spi_transmit
 590               	.LVL50:
 227:controller.c  ****     spi_transmit(a3);
 591               		.loc 1 227 0
 592 00b4 8A2D      		mov r24,r10
 593 00b6 0E94 0000 		call spi_transmit
 594               	.LVL51:
 228:controller.c  ****     spi_transmit(dlc);
 595               		.loc 1 228 0
 596 00ba 8B2D      		mov r24,r11
 597 00bc 0E94 0000 		call spi_transmit
 598               	.LVL52:
 229:controller.c  ****     for (i=0;i<8;i++)
 599               		.loc 1 229 0
 600 00c0 8C2D      		mov r24,r12
 601 00c2 0E94 0000 		call spi_transmit
 602               	.LVL53:
 220:controller.c  **** 
 603               		.loc 1 220 0
 604 00c6 6701      		movw r12,r14
 605               	.LVL54:
 606 00c8 F5E0      		ldi r31,5
 607 00ca CF0E      		add r12,r31
 608 00cc D11C      		adc r13,__zero_reg__
 609 00ce 8DE0      		ldi r24,13
 610 00d0 E80E      		add r14,r24
 611 00d2 F11C      		adc r15,__zero_reg__
 612               	.LVL55:
 613               	.L23:
 231:controller.c  ****     mcp2515_slave_release();
 614               		.loc 1 231 0 discriminator 3
 615 00d4 F601      		movw r30,r12
 616 00d6 8191      		ld r24,Z+
 617               	.LVL56:
 618 00d8 6F01      		movw r12,r30
 619               	.LVL57:
 620 00da 0E94 0000 		call spi_transmit
 621               	.LVL58:
 230:controller.c  ****         spi_transmit(*src++);
 622               		.loc 1 230 0 discriminator 3
 623 00de CE14      		cp r12,r14
 624 00e0 DF04      		cpc r13,r15
 625 00e2 01F4      		brne .L23
 232:controller.c  **** 
 626               		.loc 1 232 0
 627 00e4 289A      		sbi 0x5,0
 234:controller.c  **** 
 628               		.loc 1 234 0
 629 00e6 41E0      		ldi r20,lo8(1)
 630 00e8 63E0      		ldi r22,lo8(3)
 631 00ea 802F      		mov r24,r16
 632 00ec 0E94 0000 		call mcp2515_register_write_bit
 633               	.LVL59:
 236:controller.c  **** }
 634               		.loc 1 236 0
 635 00f0 80E0      		ldi r24,0
 636 00f2 00C0      		rjmp .L20
 637               	.LVL60:
 638               	.L25:
 201:controller.c  ****     }
 639               		.loc 1 201 0
 640 00f4 8FEF      		ldi r24,lo8(-1)
 641               	.LVL61:
 642               	.L20:
 643               	/* epilogue start */
 237:controller.c  **** 
 644               		.loc 1 237 0
 645 00f6 0F90      		pop __tmp_reg__
 646 00f8 DF91      		pop r29
 647 00fa CF91      		pop r28
 648 00fc 1F91      		pop r17
 649 00fe 0F91      		pop r16
 650 0100 FF90      		pop r15
 651 0102 EF90      		pop r14
 652 0104 DF90      		pop r13
 653 0106 CF90      		pop r12
 654 0108 BF90      		pop r11
 655 010a AF90      		pop r10
 656 010c 0895      		ret
 657               		.cfi_endproc
 658               	.LFE13:
 660               		.section	.text.can_init,"ax",@progbits
 661               	.global	can_init
 663               	can_init:
 664               	.LFB14:
 240:controller.c  ****     spi_master_init();
 665               		.loc 1 240 0
 666               		.cfi_startproc
 667               	/* prologue: function */
 668               	/* frame size = 0 */
 669               	/* stack size = 0 */
 670               	.L__stack_usage = 0
 241:controller.c  **** 
 671               		.loc 1 241 0
 672 0000 0E94 0000 		call spi_master_init
 673               	.LVL62:
 243:controller.c  **** 
 674               		.loc 1 243 0
 675 0004 209A      		sbi 0x4,0
 245:controller.c  ****     spi_transmit(MCP_RESET);
 676               		.loc 1 245 0
 677 0006 2898      		cbi 0x5,0
 246:controller.c  ****     mcp2515_slave_release();
 678               		.loc 1 246 0
 679 0008 80EC      		ldi r24,lo8(-64)
 680 000a 0E94 0000 		call spi_transmit
 681               	.LVL63:
 247:controller.c  **** 
 682               		.loc 1 247 0
 683 000e 289A      		sbi 0x5,0
 684               	.LVL64:
 685               	.LBB41:
 686               	.LBB42:
 687               		.file 2 "/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h"
   1:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    All rights reserved.
   5:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
   6:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
   9:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  12:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****      distribution.
  16:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  17:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  21:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  33:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** /* $Id$ */
  34:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  35:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  38:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #  endif
  42:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  44:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #include <inttypes.h>
  45:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #include <math.h>
  47:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  48:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** /** \file */
  49:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     \code
  51:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     \endcode
  55:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  56:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     used.
  60:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  61:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  70:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     routines linked into the application.
  78:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  79:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  83:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** */
  84:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  85:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #endif
  89:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  90:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #ifndef F_CPU
  91:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     \def F_CPU
  95:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
  97:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 103:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****     integer value.
 107:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****  */
 108:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #endif
 110:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 111:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #endif
 114:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 115:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #  include <math.h>
 119:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #endif
 120:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 121:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** /**
 122:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    \ingroup util_delay
 123:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 124:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 126:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 129:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 131:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 137:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 142:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    microseconds of delay.
 146:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 147:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    respectively.
 151:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 152:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    \note
 153:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 154:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****    not available to the compiler then.
 163:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 164:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****  */
 165:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** void
 166:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** {
 168:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 	double __tmp ;
 169:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 176:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 179:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 182:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 	#else
 183:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 		//round up by default
 184:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 	#endif
 186:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 
 187:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 688               		.loc 2 187 0
 689 0010 2FEF      		ldi r18,lo8(319999)
 690 0012 81EE      		ldi r24,hi8(319999)
 691 0014 94E0      		ldi r25,hlo8(319999)
 692 0016 2150      	1:	subi r18,1
 693 0018 8040      		sbci r24,0
 694 001a 9040      		sbci r25,0
 695 001c 01F4      		brne 1b
 696 001e 00C0      		rjmp .
 697 0020 0000      		nop
 698               	.LBE42:
 699               	.LBE41:
 251:controller.c  ****    
 700               		.loc 1 251 0
 701 0022 8EE0      		ldi r24,lo8(14)
 702 0024 0E94 0000 		call mcp2515_register_read
 703               	.LVL65:
 704 0028 807E      		andi r24,lo8(-32)
 705 002a 8038      		cpi r24,lo8(-128)
 706 002c 01F4      		brne .L30
 253:controller.c  ****     mcp2515_register_write(CNF2,0xF0);
 707               		.loc 1 253 0
 708 002e 63E0      		ldi r22,lo8(3)
 709 0030 8AE2      		ldi r24,lo8(42)
 710 0032 0E94 0000 		call mcp2515_register_write
 711               	.LVL66:
 254:controller.c  ****     mcp2515_register_write(CNF3,0x86);
 712               		.loc 1 254 0
 713 0036 60EF      		ldi r22,lo8(-16)
 714 0038 89E2      		ldi r24,lo8(41)
 715 003a 0E94 0000 		call mcp2515_register_write
 716               	.LVL67:
 255:controller.c  **** 
 717               		.loc 1 255 0
 718 003e 66E8      		ldi r22,lo8(-122)
 719 0040 88E2      		ldi r24,lo8(40)
 720 0042 0E94 0000 		call mcp2515_register_write
 721               	.LVL68:
 258:controller.c  ****     mcp2515_register_write(RXB1+xCTRL, (1<<RXM0) | (1<<RXM1));             // Buffer 1: receive eve
 722               		.loc 1 258 0
 723 0046 64E6      		ldi r22,lo8(100)
 724 0048 80E6      		ldi r24,lo8(96)
 725 004a 0E94 0000 		call mcp2515_register_write
 726               	.LVL69:
 259:controller.c  **** 
 727               		.loc 1 259 0
 728 004e 60E6      		ldi r22,lo8(96)
 729 0050 80E7      		ldi r24,lo8(112)
 730 0052 0E94 0000 		call mcp2515_register_write
 731               	.LVL70:
 262:controller.c  **** 
 732               		.loc 1 262 0
 733 0056 41E0      		ldi r20,lo8(1)
 734 0058 60E0      		ldi r22,0
 735 005a 8BE2      		ldi r24,lo8(43)
 736 005c 0E94 0000 		call mcp2515_register_write_bit
 737               	.LVL71:
 265:controller.c  **** 
 738               		.loc 1 265 0
 739 0060 41E0      		ldi r20,lo8(1)
 740 0062 61E0      		ldi r22,lo8(1)
 741 0064 8BE2      		ldi r24,lo8(43)
 742 0066 0E94 0000 		call mcp2515_register_write_bit
 743               	.LVL72:
 267:controller.c  **** 
 744               		.loc 1 267 0
 745 006a 60E0      		ldi r22,0
 746 006c 8FE0      		ldi r24,lo8(15)
 747 006e 0E94 0000 		call mcp2515_register_write
 748               	.LVL73:
 749               	.LBB43:
 750               	.LBB44:
 751               		.loc 2 187 0
 752 0072 8FE3      		ldi r24,lo8(-25537)
 753 0074 9CE9      		ldi r25,hi8(-25537)
 754 0076 0197      	1:	sbiw r24,1
 755 0078 01F4      		brne 1b
 756 007a 00C0      		rjmp .
 757 007c 0000      		nop
 758               	.LBE44:
 759               	.LBE43:
 271:controller.c  **** 
 760               		.loc 1 271 0
 761 007e 8EE0      		ldi r24,lo8(14)
 762 0080 0E94 0000 		call mcp2515_register_read
 763               	.LVL74:
 764 0084 982F      		mov r25,r24
 765 0086 907E      		andi r25,lo8(-32)
 766 0088 81E0      		ldi r24,lo8(1)
 767 008a 01F4      		brne .L29
 768 008c 80E0      		ldi r24,0
 769               	.L29:
 770 008e 8195      		neg r24
 771 0090 0895      		ret
 772               	.LVL75:
 773               	.L30:
 251:controller.c  ****    
 774               		.loc 1 251 0
 775 0092 8FEF      		ldi r24,lo8(-1)
 274:controller.c  **** 
 776               		.loc 1 274 0
 777 0094 0895      		ret
 778               		.cfi_endproc
 779               	.LFE14:
 781               		.section	.text.adc_read,"ax",@progbits
 782               	.global	adc_read
 784               	adc_read:
 785               	.LFB15:
 277:controller.c  ****     uint8_t low;
 786               		.loc 1 277 0
 787               		.cfi_startproc
 788               	.LVL76:
 789               	/* prologue: function */
 790               	/* frame size = 0 */
 791               	/* stack size = 0 */
 792               	.L__stack_usage = 0
 280:controller.c  ****     //ADCSRA = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0) | (1<<ADEN);                 // start rea
 793               		.loc 1 280 0
 794 0000 982F      		mov r25,r24
 795 0002 9F71      		andi r25,lo8(31)
 796 0004 9064      		ori r25,lo8(64)
 797 0006 9093 7C00 		sts 124,r25
 282:controller.c  ****     //if (channel==CHANNEL_VREF)
 798               		.loc 1 282 0
 799 000a 8072      		andi r24,lo8(32)
 800               	.LVL77:
 801 000c 8068      		ori r24,lo8(-128)
 802 000e 8093 7B00 		sts 123,r24
 803               	.LVL78:
 804               	.LBB45:
 805               	.LBB46:
 806               		.loc 2 187 0
 807 0012 8FE9      		ldi r24,lo8(3999)
 808 0014 9FE0      		ldi r25,hi8(3999)
 809 0016 0197      	1:	sbiw r24,1
 810 0018 01F4      		brne 1b
 811 001a 00C0      		rjmp .
 812 001c 0000      		nop
 813               	.LBE46:
 814               	.LBE45:
 285:controller.c  ****     while (bit_is_set(ADCSRA,ADSC));          // wait until done
 815               		.loc 1 285 0
 816 001e 87EC      		ldi r24,lo8(-57)
 817 0020 8093 7A00 		sts 122,r24
 818               	.L32:
 286:controller.c  ****     low = ADCL;
 819               		.loc 1 286 0 discriminator 1
 820 0024 8091 7A00 		lds r24,122
 821 0028 86FD      		sbrc r24,6
 822 002a 00C0      		rjmp .L32
 287:controller.c  ****     //result |= ((uint16_t)(ADCH))<<8;
 823               		.loc 1 287 0
 824 002c 8091 7800 		lds r24,120
 825               	.LVL79:
 289:controller.c  **** }
 826               		.loc 1 289 0
 827 0030 2091 7900 		lds r18,121
 828 0034 90E0      		ldi r25,0
 290:controller.c  **** 
 829               		.loc 1 290 0
 830 0036 922B      		or r25,r18
 831 0038 0895      		ret
 832               		.cfi_endproc
 833               	.LFE15:
 835               		.section	.text.power_check,"ax",@progbits
 837               	power_check:
 838               	.LFB18:
 307:controller.c  **** 
 308:controller.c  **** static int power_check(uint8_t* power_flags, uint16_t *supply_level, uint16_t *sense_level, uint16_
 309:controller.c  **** {
 839               		.loc 1 309 0
 840               		.cfi_startproc
 841               	.LVL80:
 842 0000 CF92      		push r12
 843               	.LCFI30:
 844               		.cfi_def_cfa_offset 3
 845               		.cfi_offset 12, -2
 846 0002 DF92      		push r13
 847               	.LCFI31:
 848               		.cfi_def_cfa_offset 4
 849               		.cfi_offset 13, -3
 850 0004 EF92      		push r14
 851               	.LCFI32:
 852               		.cfi_def_cfa_offset 5
 853               		.cfi_offset 14, -4
 854 0006 FF92      		push r15
 855               	.LCFI33:
 856               		.cfi_def_cfa_offset 6
 857               		.cfi_offset 15, -5
 858 0008 0F93      		push r16
 859               	.LCFI34:
 860               		.cfi_def_cfa_offset 7
 861               		.cfi_offset 16, -6
 862 000a 1F93      		push r17
 863               	.LCFI35:
 864               		.cfi_def_cfa_offset 8
 865               		.cfi_offset 17, -7
 866 000c CF93      		push r28
 867               	.LCFI36:
 868               		.cfi_def_cfa_offset 9
 869               		.cfi_offset 28, -8
 870 000e DF93      		push r29
 871               	.LCFI37:
 872               		.cfi_def_cfa_offset 10
 873               		.cfi_offset 29, -9
 874               	/* prologue: function */
 875               	/* frame size = 0 */
 876               	/* stack size = 8 */
 877               	.L__stack_usage = 8
 878 0010 EC01      		movw r28,r24
 879 0012 7B01      		movw r14,r22
 880 0014 8A01      		movw r16,r20
 881 0016 6901      		movw r12,r18
 310:controller.c  ****     // We test the power supply of the board
 311:controller.c  ****     // First we look if it is connected to a power supply at all
 312:controller.c  ****     // Next we enable the switch and check the status of the switch
 313:controller.c  **** 
 314:controller.c  ****     *power_flags &= POWER_FLAGS_FAULT;
 882               		.loc 1 314 0
 883 0018 8881      		ld r24,Y
 884               	.LVL81:
 885 001a 8470      		andi r24,lo8(4)
 886 001c 8883      		st Y,r24
 315:controller.c  **** 
 316:controller.c  ****     *vref = adc_read(CHANNEL_VREF);
 887               		.loc 1 316 0
 888 001e 8EE1      		ldi r24,lo8(30)
 889 0020 0E94 0000 		call adc_read
 890               	.LVL82:
 891 0024 F601      		movw r30,r12
 892 0026 9183      		std Z+1,r25
 893 0028 8083      		st Z,r24
 317:controller.c  **** 
 318:controller.c  ****     FN_DEN_SET();
 894               		.loc 1 318 0
 895 002a 2D9A      		sbi 0x5,5
 319:controller.c  ****     *sense_level = adc_read(CHANNEL_SENSE);
 896               		.loc 1 319 0
 897 002c 80E0      		ldi r24,0
 898 002e 0E94 0000 		call adc_read
 899               	.LVL83:
 900 0032 F801      		movw r30,r16
 901 0034 9183      		std Z+1,r25
 902 0036 8083      		st Z,r24
 320:controller.c  ****     FN_DEN_CLEAR();
 903               		.loc 1 320 0
 904 0038 2D98      		cbi 0x5,5
 321:controller.c  **** 
 322:controller.c  ****     if (*sense_level>1000)
 905               		.loc 1 322 0
 906 003a 8081      		ld r24,Z
 907 003c 9181      		ldd r25,Z+1
 908 003e 893E      		cpi r24,-23
 909 0040 9340      		sbci r25,3
 910 0042 00F0      		brlo .L35
 323:controller.c  ****     {
 324:controller.c  ****         *power_flags |= POWER_FLAGS_FAULT;
 911               		.loc 1 324 0
 912 0044 8881      		ld r24,Y
 913 0046 8460      		ori r24,lo8(4)
 914 0048 8883      		st Y,r24
 325:controller.c  ****         power_down();
 915               		.loc 1 325 0
 916 004a 0E94 0000 		call power_down
 917               	.LVL84:
 918               	.L35:
 326:controller.c  ****     } 
 327:controller.c  ****     
 328:controller.c  ****     if (*sense_level>0)
 919               		.loc 1 328 0
 920 004e F801      		movw r30,r16
 921 0050 8081      		ld r24,Z
 922 0052 9181      		ldd r25,Z+1
 923 0054 892B      		or r24,r25
 924 0056 01F0      		breq .L36
 329:controller.c  ****     {
 330:controller.c  ****         *power_flags |= POWER_FLAGS_SENSE;
 925               		.loc 1 330 0
 926 0058 8881      		ld r24,Y
 927 005a 8260      		ori r24,lo8(2)
 928 005c 8883      		st Y,r24
 929               	.L36:
 331:controller.c  ****     }
 332:controller.c  **** 
 333:controller.c  **** 
 334:controller.c  ****     *supply_level = adc_read(CHANNEL_VIN);
 930               		.loc 1 334 0
 931 005e 81E0      		ldi r24,lo8(1)
 932 0060 0E94 0000 		call adc_read
 933               	.LVL85:
 934 0064 F701      		movw r30,r14
 935 0066 9183      		std Z+1,r25
 936 0068 8083      		st Z,r24
 335:controller.c  ****     if (*supply_level>=32)
 937               		.loc 1 335 0
 938 006a 8097      		sbiw r24,32
 939 006c 00F0      		brlo .L37
 336:controller.c  ****     {
 337:controller.c  ****         *power_flags |= POWER_FLAGS_SUPPLY;
 940               		.loc 1 337 0
 941 006e 8881      		ld r24,Y
 942 0070 8160      		ori r24,lo8(1)
 943 0072 8883      		st Y,r24
 338:controller.c  ****         FN_LED_ORANGE_SET();
 944               		.loc 1 338 0
 945 0074 2F9A      		sbi 0x5,7
 946 0076 00C0      		rjmp .L38
 947               	.L37:
 339:controller.c  ****     }
 340:controller.c  ****     else
 341:controller.c  ****     {
 342:controller.c  ****         FN_LED_ORANGE_CLEAR();
 948               		.loc 1 342 0
 949 0078 2F98      		cbi 0x5,7
 950               	.L38:
 343:controller.c  ****     }
 344:controller.c  ****     return 0;
 345:controller.c  **** }
 951               		.loc 1 345 0
 952 007a 80E0      		ldi r24,0
 953 007c 90E0      		ldi r25,0
 954               	/* epilogue start */
 955 007e DF91      		pop r29
 956 0080 CF91      		pop r28
 957               	.LVL86:
 958 0082 1F91      		pop r17
 959 0084 0F91      		pop r16
 960               	.LVL87:
 961 0086 FF90      		pop r15
 962 0088 EF90      		pop r14
 963               	.LVL88:
 964 008a DF90      		pop r13
 965 008c CF90      		pop r12
 966               	.LVL89:
 967 008e 0895      		ret
 968               		.cfi_endproc
 969               	.LFE18:
 971               		.section	.text.__vector_1,"ax",@progbits
 972               	.global	__vector_1
 974               	__vector_1:
 975               	.LFB19:
 346:controller.c  **** 
 347:controller.c  **** #define NOCAN_HEADER_PACKET                 0x0F
 348:controller.c  **** #define NOCAN_HEADER_SUCCESS                0x10
 349:controller.c  **** #define NOCAN_HEADER_REQUEST_SOFT_RESET     0x20
 350:controller.c  **** #define NOCAN_HEADER_REQUEST_HARD_RESET     0x30
 351:controller.c  **** #define NOCAN_HEADER_REQUEST_POWER_STATUS   0x40
 352:controller.c  **** #define NOCAN_HEADER_SET_POWER              0x51
 353:controller.c  **** #define NOCAN_HEADER_SET_CAN_RES            0x61
 354:controller.c  **** #define NOCAN_HEADER_REQUEST_DEBUG          0x72
 355:controller.c  **** #define NOCAN_HEADER_VERSION                0x80
 356:controller.c  **** #define NOCAN_HEADER_FAIL                   0xE0
 357:controller.c  **** #define NOCAN_HEADER_COMMAND_UNKNOWN        0xF0
 358:controller.c  **** 
 359:controller.c  **** #include <avr/interrupt.h>
 360:controller.c  **** #define SLOTS 16
 361:controller.c  **** uint8_t circ_buffer[16*SLOTS];      // 00 TS TS F00 .. F12
 362:controller.c  **** volatile uint8_t slot_head = 0;
 363:controller.c  **** volatile uint8_t slot_tail = 0;
 364:controller.c  **** //volatile uint8_t slot_head_offset = 0;
 365:controller.c  **** uint16_t packet_id = 0;
 366:controller.c  **** 
 367:controller.c  **** ISR(INT0_vect) {
 976               		.loc 1 367 0
 977               		.cfi_startproc
 978 0000 1F92      		push r1
 979               	.LCFI38:
 980               		.cfi_def_cfa_offset 3
 981               		.cfi_offset 1, -2
 982 0002 0F92      		push r0
 983               	.LCFI39:
 984               		.cfi_def_cfa_offset 4
 985               		.cfi_offset 0, -3
 986 0004 0FB6      		in r0,__SREG__
 987 0006 0F92      		push r0
 988 0008 1124      		clr __zero_reg__
 989 000a 2F93      		push r18
 990               	.LCFI40:
 991               		.cfi_def_cfa_offset 5
 992               		.cfi_offset 18, -4
 993 000c 3F93      		push r19
 994               	.LCFI41:
 995               		.cfi_def_cfa_offset 6
 996               		.cfi_offset 19, -5
 997 000e 4F93      		push r20
 998               	.LCFI42:
 999               		.cfi_def_cfa_offset 7
 1000               		.cfi_offset 20, -6
 1001 0010 5F93      		push r21
 1002               	.LCFI43:
 1003               		.cfi_def_cfa_offset 8
 1004               		.cfi_offset 21, -7
 1005 0012 6F93      		push r22
 1006               	.LCFI44:
 1007               		.cfi_def_cfa_offset 9
 1008               		.cfi_offset 22, -8
 1009 0014 7F93      		push r23
 1010               	.LCFI45:
 1011               		.cfi_def_cfa_offset 10
 1012               		.cfi_offset 23, -9
 1013 0016 8F93      		push r24
 1014               	.LCFI46:
 1015               		.cfi_def_cfa_offset 11
 1016               		.cfi_offset 24, -10
 1017 0018 9F93      		push r25
 1018               	.LCFI47:
 1019               		.cfi_def_cfa_offset 12
 1020               		.cfi_offset 25, -11
 1021 001a AF93      		push r26
 1022               	.LCFI48:
 1023               		.cfi_def_cfa_offset 13
 1024               		.cfi_offset 26, -12
 1025 001c BF93      		push r27
 1026               	.LCFI49:
 1027               		.cfi_def_cfa_offset 14
 1028               		.cfi_offset 27, -13
 1029 001e CF93      		push r28
 1030               	.LCFI50:
 1031               		.cfi_def_cfa_offset 15
 1032               		.cfi_offset 28, -14
 1033 0020 EF93      		push r30
 1034               	.LCFI51:
 1035               		.cfi_def_cfa_offset 16
 1036               		.cfi_offset 30, -15
 1037 0022 FF93      		push r31
 1038               	.LCFI52:
 1039               		.cfi_def_cfa_offset 17
 1040               		.cfi_offset 31, -16
 1041               	/* prologue: Signal */
 1042               	/* frame size = 0 */
 1043               	/* stack size = 16 */
 1044               	.L__stack_usage = 16
 368:controller.c  ****     uint8_t slot_next = (slot_tail+1)&(SLOTS-1);
 1045               		.loc 1 368 0
 1046 0024 C091 0000 		lds r28,slot_tail
 1047 0028 CF5F      		subi r28,lo8(-(1))
 1048 002a CF70      		andi r28,lo8(15)
 1049               	.LVL90:
 369:controller.c  ****     uint8_t *buf = circ_buffer+(slot_tail<<4);
 1050               		.loc 1 369 0
 1051 002c E091 0000 		lds r30,slot_tail
 1052 0030 80E1      		ldi r24,lo8(16)
 1053 0032 E89F      		mul r30,r24
 1054 0034 F001      		movw r30,r0
 1055 0036 1124      		clr __zero_reg__
 1056 0038 E050      		subi r30,lo8(-(circ_buffer))
 1057 003a F040      		sbci r31,hi8(-(circ_buffer))
 1058               	.LVL91:
 370:controller.c  ****     
 371:controller.c  ****     buf[0] = NOCAN_HEADER_PACKET;
 1059               		.loc 1 371 0
 1060 003c 8FE0      		ldi r24,lo8(15)
 1061 003e 8083      		st Z,r24
 372:controller.c  ****     buf[1] = (packet_id>>8);
 1062               		.loc 1 372 0
 1063 0040 8091 0000 		lds r24,packet_id
 1064 0044 9091 0000 		lds r25,packet_id+1
 1065 0048 9183      		std Z+1,r25
 373:controller.c  ****     buf[2] = (packet_id&0xFF);
 1066               		.loc 1 373 0
 1067 004a 8283      		std Z+2,r24
 374:controller.c  ****     can_recv(buf+3);
 1068               		.loc 1 374 0
 1069 004c CF01      		movw r24,r30
 1070 004e 0396      		adiw r24,3
 1071 0050 0E94 0000 		call can_recv
 1072               	.LVL92:
 375:controller.c  ****     packet_id++;
 1073               		.loc 1 375 0
 1074 0054 8091 0000 		lds r24,packet_id
 1075 0058 9091 0000 		lds r25,packet_id+1
 1076 005c 0196      		adiw r24,1
 1077 005e 9093 0000 		sts packet_id+1,r25
 1078 0062 8093 0000 		sts packet_id,r24
 376:controller.c  **** 
 377:controller.c  ****     if (slot_next!=slot_head) {
 1079               		.loc 1 377 0
 1080 0066 8091 0000 		lds r24,slot_head
 1081 006a C813      		cpse r28,r24
 378:controller.c  ****         slot_tail = slot_next;
 1082               		.loc 1 378 0
 1083 006c C093 0000 		sts slot_tail,r28
 1084               	.L42:
 1085               	/* epilogue start */
 379:controller.c  ****     } 
 380:controller.c  **** }
 1086               		.loc 1 380 0
 1087 0070 FF91      		pop r31
 1088 0072 EF91      		pop r30
 1089 0074 CF91      		pop r28
 1090               	.LVL93:
 1091 0076 BF91      		pop r27
 1092 0078 AF91      		pop r26
 1093 007a 9F91      		pop r25
 1094 007c 8F91      		pop r24
 1095 007e 7F91      		pop r23
 1096 0080 6F91      		pop r22
 1097 0082 5F91      		pop r21
 1098 0084 4F91      		pop r20
 1099 0086 3F91      		pop r19
 1100 0088 2F91      		pop r18
 1101 008a 0F90      		pop r0
 1102 008c 0FBE      		out __SREG__,r0
 1103 008e 0F90      		pop r0
 1104 0090 1F90      		pop r1
 1105 0092 1895      		reti
 1106               		.cfi_endproc
 1107               	.LFE19:
 1109               		.section	.text.circ_buffer_pos,"ax",@progbits
 1110               	.global	circ_buffer_pos
 1112               	circ_buffer_pos:
 1113               	.LFB20:
 381:controller.c  **** 
 382:controller.c  **** uint8_t *circ_buffer_pos(void)
 383:controller.c  **** {
 1114               		.loc 1 383 0
 1115               		.cfi_startproc
 1116               	/* prologue: function */
 1117               	/* frame size = 0 */
 1118               	/* stack size = 0 */
 1119               	.L__stack_usage = 0
 384:controller.c  ****     if (slot_head!=slot_tail) 
 1120               		.loc 1 384 0
 1121 0000 9091 0000 		lds r25,slot_head
 1122 0004 8091 0000 		lds r24,slot_tail
 1123 0008 9817      		cp r25,r24
 1124 000a 01F0      		breq .L46
 385:controller.c  ****         return circ_buffer+slot_head*16;
 1125               		.loc 1 385 0
 1126 000c 8091 0000 		lds r24,slot_head
 1127 0010 20E1      		ldi r18,lo8(16)
 1128 0012 829F      		mul r24,r18
 1129 0014 C001      		movw r24,r0
 1130 0016 1124      		clr __zero_reg__
 1131 0018 8050      		subi r24,lo8(-(circ_buffer))
 1132 001a 9040      		sbci r25,hi8(-(circ_buffer))
 1133 001c 0895      		ret
 1134               	.L46:
 386:controller.c  ****     return 0;
 1135               		.loc 1 386 0
 1136 001e 80E0      		ldi r24,0
 1137 0020 90E0      		ldi r25,0
 387:controller.c  **** }
 1138               		.loc 1 387 0
 1139 0022 0895      		ret
 1140               		.cfi_endproc
 1141               	.LFE20:
 1143               		.section	.text.circ_buffer_advance,"ax",@progbits
 1144               	.global	circ_buffer_advance
 1146               	circ_buffer_advance:
 1147               	.LFB21:
 388:controller.c  **** 
 389:controller.c  **** void circ_buffer_advance(void)
 390:controller.c  **** {
 1148               		.loc 1 390 0
 1149               		.cfi_startproc
 1150               	/* prologue: function */
 1151               	/* frame size = 0 */
 1152               	/* stack size = 0 */
 1153               	.L__stack_usage = 0
 391:controller.c  ****     if (slot_head!=slot_tail) 
 1154               		.loc 1 391 0
 1155 0000 9091 0000 		lds r25,slot_head
 1156 0004 8091 0000 		lds r24,slot_tail
 1157 0008 9817      		cp r25,r24
 1158 000a 01F0      		breq .L47
 392:controller.c  ****     {
 393:controller.c  ****         cli();
 1159               		.loc 1 393 0
 1160               	/* #APP */
 1161               	 ;  393 "controller.c" 1
 1162 000c F894      		cli
 1163               	 ;  0 "" 2
 394:controller.c  ****         slot_head = (slot_head+1)&(SLOTS-1);
 1164               		.loc 1 394 0
 1165               	/* #NOAPP */
 1166 000e 8091 0000 		lds r24,slot_head
 1167 0012 8F5F      		subi r24,lo8(-(1))
 1168 0014 8F70      		andi r24,lo8(15)
 1169 0016 8093 0000 		sts slot_head,r24
 395:controller.c  ****         sei();
 1170               		.loc 1 395 0
 1171               	/* #APP */
 1172               	 ;  395 "controller.c" 1
 1173 001a 7894      		sei
 1174               	 ;  0 "" 2
 1175               	/* #NOAPP */
 1176               	.L47:
 1177 001c 0895      		ret
 1178               		.cfi_endproc
 1179               	.LFE21:
 1181               		.section	.text.circ_buffer_clear,"ax",@progbits
 1182               	.global	circ_buffer_clear
 1184               	circ_buffer_clear:
 1185               	.LFB22:
 396:controller.c  ****     }
 397:controller.c  **** }
 398:controller.c  **** 
 399:controller.c  **** void circ_buffer_clear(void)
 400:controller.c  **** {
 1186               		.loc 1 400 0
 1187               		.cfi_startproc
 1188               	/* prologue: function */
 1189               	/* frame size = 0 */
 1190               	/* stack size = 0 */
 1191               	.L__stack_usage = 0
 401:controller.c  ****     cli();
 1192               		.loc 1 401 0
 1193               	/* #APP */
 1194               	 ;  401 "controller.c" 1
 1195 0000 F894      		cli
 1196               	 ;  0 "" 2
 402:controller.c  ****     slot_head = 0;
 1197               		.loc 1 402 0
 1198               	/* #NOAPP */
 1199 0002 1092 0000 		sts slot_head,__zero_reg__
 403:controller.c  ****     slot_tail = 0;
 1200               		.loc 1 403 0
 1201 0006 1092 0000 		sts slot_tail,__zero_reg__
 404:controller.c  ****     sei();
 1202               		.loc 1 404 0
 1203               	/* #APP */
 1204               	 ;  404 "controller.c" 1
 1205 000a 7894      		sei
 1206               	 ;  0 "" 2
 1207               	/* #NOAPP */
 1208 000c 0895      		ret
 1209               		.cfi_endproc
 1210               	.LFE22:
 1212               		.section	.text.startup.main,"ax",@progbits
 1213               	.global	main
 1215               	main:
 1216               	.LFB23:
 405:controller.c  **** }
 406:controller.c  **** 
 407:controller.c  **** // Basic command interpreter for controlling port pins
 408:controller.c  **** int main(void)
 409:controller.c  **** {
 1217               		.loc 1 409 0
 1218               		.cfi_startproc
 1219 0000 CF93      		push r28
 1220               	.LCFI53:
 1221               		.cfi_def_cfa_offset 3
 1222               		.cfi_offset 28, -2
 1223 0002 DF93      		push r29
 1224               	.LCFI54:
 1225               		.cfi_def_cfa_offset 4
 1226               		.cfi_offset 29, -3
 1227 0004 CDB7      		in r28,__SP_L__
 1228 0006 DEB7      		in r29,__SP_H__
 1229               	.LCFI55:
 1230               		.cfi_def_cfa_register 28
 1231 0008 A797      		sbiw r28,39
 1232               	.LCFI56:
 1233               		.cfi_def_cfa_offset 43
 1234 000a 0FB6      		in __tmp_reg__,__SREG__
 1235 000c F894      		cli
 1236 000e DEBF      		out __SP_H__,r29
 1237 0010 0FBE      		out __SREG__,__tmp_reg__
 1238 0012 CDBF      		out __SP_L__,r28
 1239               	/* prologue: function */
 1240               	/* frame size = 39 */
 1241               	/* stack size = 41 */
 1242               	.L__stack_usage = 41
 410:controller.c  ****     uint8_t i;
 411:controller.c  ****     uint8_t can_buffer[16];
 412:controller.c  ****     uint8_t can_info[16];
 413:controller.c  ****     uint8_t *packet;
 414:controller.c  ****     uint8_t vin_flags = 0;
 1243               		.loc 1 414 0
 1244 0014 1FA2      		std Y+39,__zero_reg__
 415:controller.c  **** 	uint16_t vin_sense_level = 0;
 1245               		.loc 1 415 0
 1246 0016 1EA2      		std Y+38,__zero_reg__
 1247 0018 1DA2      		std Y+37,__zero_reg__
 416:controller.c  ****     uint16_t vin_supply_level = 0;
 1248               		.loc 1 416 0
 1249 001a 1CA2      		std Y+36,__zero_reg__
 1250 001c 1BA2      		std Y+35,__zero_reg__
 417:controller.c  ****     uint16_t vref_1_1 = 0;
 1251               		.loc 1 417 0
 1252 001e 1AA2      		std Y+34,__zero_reg__
 1253 0020 19A2      		std Y+33,__zero_reg__
 418:controller.c  **** 
 419:controller.c  ****     // in case that's what got us here
 420:controller.c  ****     MCUSR = 0;
 1254               		.loc 1 420 0
 1255 0022 14BE      		out 0x34,__zero_reg__
 1256               	.LBB47:
 1257               	.LBB48:
 1258               		.file 3 "/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h"
   1:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    All rights reserved.
   4:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
   5:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
   8:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  11:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****      distribution.
  15:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  16:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  20:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  32:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** /* $Id$ */
  33:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  34:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** /*
  35:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****  */
  37:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  38:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  41:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  44:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** /** \file */
  45:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  48:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     the manipulation.
  56:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  57:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  61:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     the following:
  68:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  69:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     \code
  70:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  73:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  75:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     {
  80:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       wdt_disable();
  83:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     }
  84:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     \endcode
  85:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  86:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** */
  91:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  92:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** /**
  93:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** */
  98:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
  99:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 101:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 103:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #else
 106:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #endif
 108:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 109:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #else
 114:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #endif
 116:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 117:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #else
 120:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #endif
 122:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 123:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 125:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 126:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** /**
 127:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 134:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** */
 136:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 137:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 138:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 140:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 142:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** do { \
 144:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** ); \
 162:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** } while(0)
 163:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 164:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** do { \
 166:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** ); \
 179:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** } while(0)
 180:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 181:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 183:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** /*
 184:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** ** At the same time,
 188:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****    sync is finished).
 194:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** */
 195:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** do { \
 197:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : "r0" \
 216:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** ); \
 217:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** } while(0)
 218:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 219:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : \
 227:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : "r0" \
 233:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** );
 234:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 235:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 237:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 239:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : "r16" \
 254:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** )
 255:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 256:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** do { \
 258:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****     : "r16" \
 275:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** ); \
 276:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** }while(0)
 277:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 278:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 280:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** static __inline__
 281:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** {
 284:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 286:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: "r0"
 300:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			);
 301:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 302:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 304:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: "r0"
 318:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			);
 319:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 320:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 322:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: "r0"
 336:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			);
 337:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 338:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	else
 339:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****  	{
 340:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			: "r0"
 354:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 			);
 355:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 356:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** }
 357:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 358:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** static __inline__
 359:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** {
 362:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 364:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: /*no output */
 375:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: "r0"
 381:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				);
 382:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 383:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 385:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: /*no output */
 396:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: "r0"
 402:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				);
 403:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 404:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 406:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: /*no output */
 417:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: "r0"
 423:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				);
 424:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 425:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	else
 426:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 427:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: /*no output */
 438:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: "r0"
 444:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				);
 445:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 446:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** }
 447:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 448:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** #else
 449:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 450:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** static __inline__
 451:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** {
 454:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 456:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: "r0"
 469:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		);
 470:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 471:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	else
 472:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 473:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 474:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 475:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 476:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 477:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 478:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 479:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 480:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: /* no outputs */
 481:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 482:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 483:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 484:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 485:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: "r0"
 486:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		);
 487:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 488:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** }
 489:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 
 490:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** static __inline__
 491:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 492:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** void wdt_disable (void)
 493:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** {
 494:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 495:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 496:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 497:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 498:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 499:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 500:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 501:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 502:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 503:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 504:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 505:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 506:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 507:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 508:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 509:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				: "r0"
 510:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		);
 511:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	}
 512:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	else
 513:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 	{
 514:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 515:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 1259               		.loc 3 515 0
 1260               	/* #APP */
 1261               	 ;  515 "/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h" 1
 1262 0024 0FB6      		in __tmp_reg__,__SREG__
 1263 0026 F894      		cli
 1264 0028 A895      		wdr
 1265 002a 8091 6000 		lds r24,96
 1266 002e 8861      		ori r24,24
 1267 0030 8093 6000 		sts 96,r24
 1268 0034 1092 6000 		sts 96,__zero_reg__
 1269 0038 0FBE      		out __SREG__,__tmp_reg__
 1270               		
 1271               	 ;  0 "" 2
 1272               	.LVL94:
 1273               	/* #NOAPP */
 1274               	.LBE48:
 1275               	.LBE47:
 421:controller.c  ****     wdt_disable();
 422:controller.c  **** 
 423:controller.c  ****     // set for 16 MHz clock
 424:controller.c  **** 	CPU_PRESCALE(0);
 1276               		.loc 1 424 0
 1277 003a 80E8      		ldi r24,lo8(-128)
 1278 003c 8093 6100 		sts 97,r24
 1279 0040 1092 6100 		sts 97,__zero_reg__
 425:controller.c  **** 
 426:controller.c  ****     // ADC config
 427:controller.c  ****     // Reference is AVCC with external capacitor on AREF pin
 428:controller.c  ****     ADMUX = (1 << REFS0);
 1280               		.loc 1 428 0
 1281 0044 80E4      		ldi r24,lo8(64)
 1282 0046 8093 7C00 		sts 124,r24
 429:controller.c  ****     // prescaler = 128 -> 16Mhz/128 -> 125Khz
 430:controller.c  ****     // Freq must be between 50Khz and 200Khz
 431:controller.c  ****     ADCSRA = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0) | (1<<ADEN); 
 1283               		.loc 1 431 0
 1284 004a 87E8      		ldi r24,lo8(-121)
 1285 004c 8093 7A00 		sts 122,r24
 432:controller.c  **** 
 433:controller.c  ****     FN_INT_CONFIG();    // PD0 is input (IN PIN)
 1286               		.loc 1 433 0
 1287 0050 5098      		cbi 0xa,0
 434:controller.c  ****     FN_IN_CONFIG();     // this is the on/off switch for VIN (e.g. 12v)
 1288               		.loc 1 434 0
 1289 0052 6E9A      		sbi 0xd,6
 435:controller.c  ****     FN_DEN_CONFIG();    // Diagnosis enable switch
 1290               		.loc 1 435 0
 1291 0054 259A      		sbi 0x4,5
 436:controller.c  ****     FN_LED_ORANGE_CONFIG();
 1292               		.loc 1 436 0
 1293 0056 279A      		sbi 0x4,7
 437:controller.c  ****     FN_LED_RED_CONFIG();
 1294               		.loc 1 437 0
 1295 0058 269A      		sbi 0x4,6
 438:controller.c  ****     FN_CAN_R_CONFIG();
 1296               		.loc 1 438 0
 1297 005a 249A      		sbi 0x4,4
 439:controller.c  ****     FN_CAN_R_CLEAR();           // ENABLE CAN RES BY PUTTING MOSFET TO 0 WHICH IS THE DEFAULT
 1298               		.loc 1 439 0
 1299 005c 2C98      		cbi 0x5,4
 440:controller.c  ****    
 441:controller.c  ****     // use a timer to clock checking the switch status
 442:controller.c  ****     TCCR0A = 0; // normal mode of operation timer0
 1300               		.loc 1 442 0
 1301 005e 14BC      		out 0x24,__zero_reg__
 443:controller.c  ****     TCCR0B = (1<<CS00); // divide by 1024 (the timer will overflow in approx 16ms at 16Mhz)
 1302               		.loc 1 443 0
 1303 0060 81E0      		ldi r24,lo8(1)
 1304 0062 85BD      		out 0x25,r24
 444:controller.c  ****  
 445:controller.c  **** 
 446:controller.c  ****     EIMSK |= (1 << INT0);
 1305               		.loc 1 446 0
 1306 0064 E89A      		sbi 0x1d,0
 447:controller.c  ****     // EICRA &= ~((1 << ISC01)|(1 << ISC00)); // this is the default, no need to set
 448:controller.c  **** 
 449:controller.c  **** 	// initialize the USB, and then wait for the host
 450:controller.c  **** 	// to set configuration.  If the device is powered
 451:controller.c  **** 	// without a PC connected to the USB port, this 
 452:controller.c  **** 	// will wait forever.
 453:controller.c  **** 
 454:controller.c  **** 	usb_init();
 1307               		.loc 1 454 0
 1308 0066 0E94 0000 		call usb_init
 1309               	.LVL95:
 1310               	.L51:
 455:controller.c  **** 	while (!usb_configured()) /* wait */ ;
 1311               		.loc 1 455 0 discriminator 1
 1312 006a 0E94 0000 		call usb_configured
 1313               	.LVL96:
 1314 006e 8823      		tst r24
 1315 0070 01F0      		breq .L51
 1316 0072 85E0      		ldi r24,lo8(5)
 1317               	.L52:
 1318               	.LVL97:
 456:controller.c  ****     for (i=0;i<5;i++)
 457:controller.c  ****     {
 458:controller.c  ****         FN_LED_ORANGE_SET();
 1319               		.loc 1 458 0 discriminator 3
 1320 0074 2F9A      		sbi 0x5,7
 1321               	.LVL98:
 1322               	.LBB49:
 1323               	.LBB50:
 1324               		.loc 2 187 0 discriminator 3
 1325 0076 2FEF      		ldi r18,lo8(319999)
 1326 0078 31EE      		ldi r19,hi8(319999)
 1327 007a 94E0      		ldi r25,hlo8(319999)
 1328 007c 2150      	1:	subi r18,1
 1329 007e 3040      		sbci r19,0
 1330 0080 9040      		sbci r25,0
 1331 0082 01F4      		brne 1b
 1332 0084 00C0      		rjmp .
 1333 0086 0000      		nop
 1334               	.LBE50:
 1335               	.LBE49:
 459:controller.c  **** 	    _delay_ms(100);
 460:controller.c  ****         FN_LED_ORANGE_CLEAR();
 1336               		.loc 1 460 0 discriminator 3
 1337 0088 2F98      		cbi 0x5,7
 461:controller.c  ****         FN_LED_RED_SET();
 1338               		.loc 1 461 0 discriminator 3
 1339 008a 2E9A      		sbi 0x5,6
 1340               	.LVL99:
 1341               	.LBB51:
 1342               	.LBB52:
 1343               		.loc 2 187 0 discriminator 3
 1344 008c 2FEF      		ldi r18,lo8(319999)
 1345 008e 31EE      		ldi r19,hi8(319999)
 1346 0090 94E0      		ldi r25,hlo8(319999)
 1347 0092 2150      	1:	subi r18,1
 1348 0094 3040      		sbci r19,0
 1349 0096 9040      		sbci r25,0
 1350 0098 01F4      		brne 1b
 1351 009a 00C0      		rjmp .
 1352 009c 0000      		nop
 1353               	.LBE52:
 1354               	.LBE51:
 462:controller.c  **** 	    _delay_ms(100);
 463:controller.c  ****         FN_LED_RED_CLEAR();
 1355               		.loc 1 463 0 discriminator 3
 1356 009e 2E98      		cbi 0x5,6
 1357               	.LVL100:
 1358 00a0 8150      		subi r24,lo8(-(-1))
 1359               	.LVL101:
 456:controller.c  ****     {
 1360               		.loc 1 456 0 discriminator 3
 1361 00a2 01F4      		brne .L52
 464:controller.c  ****     }
 465:controller.c  **** 
 466:controller.c  ****     
 467:controller.c  ****     // We now test the power supply of the board
 468:controller.c  ****     power_up();
 1362               		.loc 1 468 0
 1363 00a4 0E94 0000 		call power_up
 1364               	.LVL102:
 469:controller.c  ****     power_check(&vin_flags, &vin_supply_level, &vin_sense_level,&vref_1_1);
 1365               		.loc 1 469 0
 1366 00a8 9E01      		movw r18,r28
 1367 00aa 2F5D      		subi r18,-33
 1368 00ac 3F4F      		sbci r19,-1
 1369 00ae AE01      		movw r20,r28
 1370 00b0 4B5D      		subi r20,-37
 1371 00b2 5F4F      		sbci r21,-1
 1372 00b4 BE01      		movw r22,r28
 1373 00b6 6D5D      		subi r22,-35
 1374 00b8 7F4F      		sbci r23,-1
 1375 00ba CE01      		movw r24,r28
 1376 00bc 8796      		adiw r24,39
 1377 00be 0E94 0000 		call power_check
 1378               	.LVL103:
 470:controller.c  **** 
 471:controller.c  **** 	while (1) {
 472:controller.c  **** 		usb_serial_flush_input();
 1379               		.loc 1 472 0
 1380 00c2 0E94 0000 		call usb_serial_flush_input
 1381               	.LVL104:
 473:controller.c  **** 
 474:controller.c  ****         can_init();
 1382               		.loc 1 474 0
 1383 00c6 0E94 0000 		call can_init
 1384               	.LVL105:
 475:controller.c  **** 
 476:controller.c  **** 		while (1) {
 477:controller.c  ****             // If there are packets available, send them to the host
 478:controller.c  ****             while ((packet = circ_buffer_pos())!=0) 
 479:controller.c  ****             {
 480:controller.c  ****                 put_byte_n(packet,16);
 481:controller.c  ****                 circ_buffer_advance();
 482:controller.c  ****             }
 483:controller.c  ****             // TODO: we should flush here?
 484:controller.c  **** 
 485:controller.c  ****             // if the host wants to send something, get it
 486:controller.c  ****             if (usb_serial_available()>0) {
 487:controller.c  ****                 if (get_byte(can_buffer)==R_ERROR) break; // panic!!!
 488:controller.c  ****                 for (i=0;i<(can_buffer[0]&0xF);i++)
 489:controller.c  ****                 {    
 490:controller.c  ****                     get_byte(can_buffer+i+1);
 491:controller.c  ****                 } 
 492:controller.c  **** 
 493:controller.c  ****                 switch (can_buffer[0]) {
 494:controller.c  ****                     case NOCAN_HEADER_PACKET:
 495:controller.c  ****                         if (can_send(can_buffer+3)!=R_OK)
 496:controller.c  ****                             put_byte(NOCAN_HEADER_FAIL);
 497:controller.c  ****                         else
 498:controller.c  ****                             put_byte(NOCAN_HEADER_SUCCESS);
 499:controller.c  ****                         break;
 500:controller.c  ****                     case NOCAN_HEADER_REQUEST_SOFT_RESET:
 501:controller.c  ****                         if (can_init()!=R_OK)
 502:controller.c  ****                             put_byte(NOCAN_HEADER_FAIL);
 503:controller.c  ****                         else
 504:controller.c  ****                             put_byte(NOCAN_HEADER_SUCCESS);
 505:controller.c  ****                         break;
 506:controller.c  ****                     case NOCAN_HEADER_REQUEST_HARD_RESET:
 507:controller.c  ****                         put_byte(NOCAN_HEADER_SUCCESS);
 508:controller.c  ****                         // TODO: flush output
 509:controller.c  ****                         wdt_enable(WDTO_15MS);
 510:controller.c  ****                         for (;;);
 511:controller.c  ****                     case NOCAN_HEADER_REQUEST_POWER_STATUS:
 512:controller.c  ****                         can_info[0] = NOCAN_HEADER_SUCCESS | 7;
 1385               		.loc 1 512 0
 1386 00ca 07E1      		ldi r16,lo8(23)
 513:controller.c  ****                         can_info[1] = vin_flags;
 514:controller.c  ****                         can_info[2] = (vin_supply_level >> 8);
 515:controller.c  ****                         can_info[3] = (vin_supply_level & 0xFF);
 516:controller.c  ****                         can_info[4] = (vin_sense_level >> 8);
 517:controller.c  ****                         can_info[5] = (vin_sense_level & 0xFF);
 518:controller.c  ****                         can_info[6] = (vref_1_1 >> 8);
 519:controller.c  ****                         can_info[7] = (vref_1_1 & 0xFF);
 520:controller.c  ****                         put_byte_n(can_info,8);
 521:controller.c  ****                         break;
 522:controller.c  ****                     case NOCAN_HEADER_SET_POWER:
 523:controller.c  ****                         vin_flags &= ~POWER_FLAGS_FAULT; // reset fault line
 524:controller.c  ****                         if (can_buffer[1]!=0)
 525:controller.c  ****                         {
 526:controller.c  ****                             power_up();
 527:controller.c  ****                         }
 528:controller.c  ****                         else
 529:controller.c  ****                         {
 530:controller.c  ****                             power_down();
 531:controller.c  ****                         }
 532:controller.c  ****                         put_byte(NOCAN_HEADER_SUCCESS);
 533:controller.c  ****                         break;
 534:controller.c  ****                     case NOCAN_HEADER_SET_CAN_RES:
 535:controller.c  ****                         if (can_buffer[1]!=0)
 536:controller.c  ****                             FN_CAN_R_SET();             // DISABLE CAN RES. (inverted logic)
 537:controller.c  ****                         else
 538:controller.c  ****                             FN_CAN_R_CLEAR();           // ENABLE CAN RES.
 539:controller.c  ****                         put_byte(NOCAN_HEADER_SUCCESS);
 540:controller.c  ****                         break;
 541:controller.c  ****                     case NOCAN_HEADER_REQUEST_DEBUG:
 542:controller.c  ****                         can_buffer[2] &= 0xF;
 543:controller.c  ****                         can_info[0] = (NOCAN_HEADER_REQUEST_DEBUG&0xF0)|can_buffer[2];
 544:controller.c  ****                         for (i=0;i<can_buffer[2];i++)
 545:controller.c  ****                           can_info[1+i] = mcp2515_register_read(can_buffer[1]+i);
 546:controller.c  ****                         put_byte_n(can_info,can_buffer[2]+1);
 547:controller.c  ****                         break;
 548:controller.c  ****                     case NOCAN_HEADER_VERSION:
 549:controller.c  ****                         can_info[0] = NOCAN_HEADER_SUCCESS | 4;
 1387               		.loc 1 549 0
 1388 00cc 84E1      		ldi r24,lo8(20)
 1389 00ce F82E      		mov r15,r24
 550:controller.c  ****                         can_info[2] = 'C';
 551:controller.c  ****                         can_info[2] = 'A';
 552:controller.c  ****                         can_info[2] = 'N';
 553:controller.c  ****                         can_info[2] = '0';
 1390               		.loc 1 553 0
 1391 00d0 90E3      		ldi r25,lo8(48)
 1392 00d2 E92E      		mov r14,r25
 1393               	.L53:
 478:controller.c  ****             {
 1394               		.loc 1 478 0
 1395 00d4 0E94 0000 		call circ_buffer_pos
 1396               	.LVL106:
 1397 00d8 0097      		sbiw r24,0
 1398 00da 01F0      		breq .L89
 1399               	.LVL107:
 1400               	.LBB53:
 1401               	.LBB54:
 119:controller.c  **** }
 1402               		.loc 1 119 0
 1403 00dc 60E1      		ldi r22,lo8(16)
 1404 00de 70E0      		ldi r23,0
 1405 00e0 0E94 0000 		call usb_serial_write
 1406               	.LVL108:
 1407               	.LBE54:
 1408               	.LBE53:
 481:controller.c  ****             }
 1409               		.loc 1 481 0
 1410 00e4 0E94 0000 		call circ_buffer_advance
 1411               	.LVL109:
 1412 00e8 00C0      		rjmp .L53
 1413               	.LVL110:
 1414               	.L89:
 486:controller.c  ****                 if (get_byte(can_buffer)==R_ERROR) break; // panic!!!
 1415               		.loc 1 486 0
 1416 00ea 0E94 0000 		call usb_serial_available
 1417               	.LVL111:
 1418 00ee 8823      		tst r24
 1419 00f0 01F4      		brne .+2
 1420 00f2 00C0      		rjmp .L55
 487:controller.c  ****                 for (i=0;i<(can_buffer[0]&0xF);i++)
 1421               		.loc 1 487 0
 1422 00f4 CE01      		movw r24,r28
 1423 00f6 4196      		adiw r24,17
 1424 00f8 0E94 0000 		call get_byte
 1425               	.LVL112:
 488:controller.c  ****                 {    
 1426               		.loc 1 488 0
 1427 00fc 10E0      		ldi r17,0
 1428               	.LVL113:
 1429               	.L56:
 488:controller.c  ****                 {    
 1430               		.loc 1 488 0 is_stmt 0 discriminator 1
 1431 00fe 9989      		ldd r25,Y+17
 1432 0100 212F      		mov r18,r17
 1433 0102 30E0      		ldi r19,0
 1434 0104 492F      		mov r20,r25
 1435 0106 4F70      		andi r20,lo8(15)
 1436 0108 50E0      		ldi r21,0
 1437 010a 2417      		cp r18,r20
 1438 010c 3507      		cpc r19,r21
 1439 010e 04F4      		brge .L90
 490:controller.c  ****                 } 
 1440               		.loc 1 490 0 is_stmt 1 discriminator 3
 1441 0110 C901      		movw r24,r18
 1442 0112 0196      		adiw r24,1
 1443 0114 21E1      		ldi r18,lo8(17)
 1444 0116 30E0      		ldi r19,0
 1445 0118 2C0F      		add r18,r28
 1446 011a 3D1F      		adc r19,r29
 1447 011c 820F      		add r24,r18
 1448 011e 931F      		adc r25,r19
 1449 0120 0E94 0000 		call get_byte
 1450               	.LVL114:
 488:controller.c  ****                 {    
 1451               		.loc 1 488 0 discriminator 3
 1452 0124 1F5F      		subi r17,lo8(-(1))
 1453               	.LVL115:
 1454 0126 00C0      		rjmp .L56
 1455               	.L90:
 493:controller.c  ****                     case NOCAN_HEADER_PACKET:
 1456               		.loc 1 493 0
 1457 0128 9034      		cpi r25,lo8(64)
 1458 012a 01F4      		brne .+2
 1459 012c 00C0      		rjmp .L59
 1460 012e 00F4      		brsh .L60
 1461 0130 9032      		cpi r25,lo8(32)
 1462 0132 01F0      		breq .L61
 1463 0134 9033      		cpi r25,lo8(48)
 1464 0136 01F0      		breq .L62
 1465 0138 9F30      		cpi r25,lo8(15)
 1466 013a 01F0      		breq .+2
 1467 013c 00C0      		rjmp .L58
 495:controller.c  ****                             put_byte(NOCAN_HEADER_FAIL);
 1468               		.loc 1 495 0
 1469 013e CE01      		movw r24,r28
 1470 0140 4496      		adiw r24,20
 1471 0142 0E94 0000 		call can_send
 1472               	.LVL116:
 1473 0146 00C0      		rjmp .L88
 1474               	.L60:
 493:controller.c  ****                     case NOCAN_HEADER_PACKET:
 1475               		.loc 1 493 0
 1476 0148 9136      		cpi r25,lo8(97)
 1477 014a 01F4      		brne .+2
 1478 014c 00C0      		rjmp .L64
 1479 014e 00F4      		brsh .L65
 1480 0150 9135      		cpi r25,lo8(81)
 1481 0152 01F0      		breq .L66
 1482 0154 00C0      		rjmp .L58
 1483               	.L65:
 1484 0156 9237      		cpi r25,lo8(114)
 1485 0158 01F4      		brne .+2
 1486 015a 00C0      		rjmp .L67
 1487 015c 9038      		cpi r25,lo8(-128)
 1488 015e 01F0      		breq .+2
 1489 0160 00C0      		rjmp .L58
 549:controller.c  ****                         can_info[2] = 'C';
 1490               		.loc 1 549 0
 1491 0162 F982      		std Y+1,r15
 1492               		.loc 1 553 0
 1493 0164 EB82      		std Y+3,r14
 1494               	.LVL117:
 1495               	.LBB55:
 1496               	.LBB56:
 119:controller.c  **** }
 1497               		.loc 1 119 0
 1498 0166 65E0      		ldi r22,lo8(5)
 1499 0168 70E0      		ldi r23,0
 1500 016a 00C0      		rjmp .L87
 1501               	.LVL118:
 1502               	.L61:
 1503               	.LBE56:
 1504               	.LBE55:
 501:controller.c  ****                             put_byte(NOCAN_HEADER_FAIL);
 1505               		.loc 1 501 0
 1506 016c 0E94 0000 		call can_init
 1507               	.LVL119:
 1508               	.L88:
 495:controller.c  ****                             put_byte(NOCAN_HEADER_FAIL);
 1509               		.loc 1 495 0
 1510 0170 8823      		tst r24
 1511 0172 01F0      		breq .L69
 1512               	.LVL120:
 1513               	.LBB58:
 1514               	.LBB59:
 112:controller.c  **** }
 1515               		.loc 1 112 0
 1516 0174 80EE      		ldi r24,lo8(-32)
 1517 0176 00C0      		rjmp .L86
 1518               	.LVL121:
 1519               	.L66:
 1520               	.LBE59:
 1521               	.LBE58:
 523:controller.c  ****                         if (can_buffer[1]!=0)
 1522               		.loc 1 523 0
 1523 0178 8FA1      		ldd r24,Y+39
 1524 017a 8B7F      		andi r24,lo8(-5)
 1525 017c 8FA3      		std Y+39,r24
 524:controller.c  ****                         {
 1526               		.loc 1 524 0
 1527 017e 8A89      		ldd r24,Y+18
 1528 0180 8823      		tst r24
 1529 0182 01F0      		breq .L73
 526:controller.c  ****                         }
 1530               		.loc 1 526 0
 1531 0184 0E94 0000 		call power_up
 1532               	.LVL122:
 1533               	.L69:
 1534               	.LBB60:
 1535               	.LBB61:
 112:controller.c  **** }
 1536               		.loc 1 112 0
 1537 0188 80E1      		ldi r24,lo8(16)
 1538 018a 00C0      		rjmp .L86
 1539               	.LVL123:
 1540               	.L62:
 1541               	.LBE61:
 1542               	.LBE60:
 1543               	.LBB62:
 1544               	.LBB63:
 1545 018c 80E1      		ldi r24,lo8(16)
 1546 018e 0E94 0000 		call usb_serial_putchar_nowait
 1547               	.LVL124:
 1548               	.LBE63:
 1549               	.LBE62:
 1550               	.LBB64:
 1551               	.LBB65:
 473:/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 1552               		.loc 3 473 0
 1553 0192 98E0      		ldi r25,lo8(8)
 1554 0194 88E1      		ldi r24,lo8(24)
 1555               	/* #APP */
 1556               	 ;  473 "/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/avr/wdt.h" 1
 1557 0196 0FB6      		in __tmp_reg__,__SREG__
 1558 0198 F894      		cli
 1559 019a A895      		wdr
 1560 019c 8093 6000 		sts 96, r24
 1561 01a0 0FBE      		out __SREG__,__tmp_reg__
 1562 01a2 9093 6000 		sts 96, r25
 1563               	 	
 1564               	 ;  0 "" 2
 1565               	/* #NOAPP */
 1566               	.L72:
 1567               	.LBE65:
 1568               	.LBE64:
 510:controller.c  ****                     case NOCAN_HEADER_REQUEST_POWER_STATUS:
 1569               		.loc 1 510 0 discriminator 1
 1570 01a6 00C0      		rjmp .L72
 1571               	.LVL125:
 1572               	.L59:
 512:controller.c  ****                         can_info[1] = vin_flags;
 1573               		.loc 1 512 0
 1574 01a8 0983      		std Y+1,r16
 513:controller.c  ****                         can_info[2] = (vin_supply_level >> 8);
 1575               		.loc 1 513 0
 1576 01aa 8FA1      		ldd r24,Y+39
 1577 01ac 8A83      		std Y+2,r24
 514:controller.c  ****                         can_info[3] = (vin_supply_level & 0xFF);
 1578               		.loc 1 514 0
 1579 01ae 8BA1      		ldd r24,Y+35
 1580 01b0 9CA1      		ldd r25,Y+36
 1581 01b2 9B83      		std Y+3,r25
 515:controller.c  ****                         can_info[4] = (vin_sense_level >> 8);
 1582               		.loc 1 515 0
 1583 01b4 8C83      		std Y+4,r24
 516:controller.c  ****                         can_info[5] = (vin_sense_level & 0xFF);
 1584               		.loc 1 516 0
 1585 01b6 8DA1      		ldd r24,Y+37
 1586 01b8 9EA1      		ldd r25,Y+38
 1587 01ba 9D83      		std Y+5,r25
 517:controller.c  ****                         can_info[6] = (vref_1_1 >> 8);
 1588               		.loc 1 517 0
 1589 01bc 8E83      		std Y+6,r24
 518:controller.c  ****                         can_info[7] = (vref_1_1 & 0xFF);
 1590               		.loc 1 518 0
 1591 01be 89A1      		ldd r24,Y+33
 1592 01c0 9AA1      		ldd r25,Y+34
 1593 01c2 9F83      		std Y+7,r25
 519:controller.c  ****                         put_byte_n(can_info,8);
 1594               		.loc 1 519 0
 1595 01c4 8887      		std Y+8,r24
 1596               	.LVL126:
 1597               	.LBB66:
 1598               	.LBB67:
 119:controller.c  **** }
 1599               		.loc 1 119 0
 1600 01c6 68E0      		ldi r22,lo8(8)
 1601 01c8 70E0      		ldi r23,0
 1602 01ca 00C0      		rjmp .L87
 1603               	.LVL127:
 1604               	.L73:
 1605               	.LBE67:
 1606               	.LBE66:
 530:controller.c  ****                         }
 1607               		.loc 1 530 0
 1608 01cc 0E94 0000 		call power_down
 1609               	.LVL128:
 1610 01d0 00C0      		rjmp .L69
 1611               	.L64:
 535:controller.c  ****                             FN_CAN_R_SET();             // DISABLE CAN RES. (inverted logic)
 1612               		.loc 1 535 0
 1613 01d2 8A89      		ldd r24,Y+18
 1614 01d4 8823      		tst r24
 1615 01d6 01F0      		breq .L74
 536:controller.c  ****                         else
 1616               		.loc 1 536 0
 1617 01d8 2C9A      		sbi 0x5,4
 1618 01da 00C0      		rjmp .L69
 1619               	.L74:
 538:controller.c  ****                         put_byte(NOCAN_HEADER_SUCCESS);
 1620               		.loc 1 538 0
 1621 01dc 2C98      		cbi 0x5,4
 1622 01de 00C0      		rjmp .L69
 1623               	.L67:
 542:controller.c  ****                         can_info[0] = (NOCAN_HEADER_REQUEST_DEBUG&0xF0)|can_buffer[2];
 1624               		.loc 1 542 0
 1625 01e0 8B89      		ldd r24,Y+19
 1626 01e2 8F70      		andi r24,lo8(15)
 1627 01e4 8B8B      		std Y+19,r24
 543:controller.c  ****                         for (i=0;i<can_buffer[2];i++)
 1628               		.loc 1 543 0
 1629 01e6 8067      		ori r24,lo8(112)
 1630 01e8 8983      		std Y+1,r24
 1631               	.LVL129:
 544:controller.c  ****                           can_info[1+i] = mcp2515_register_read(can_buffer[1]+i);
 1632               		.loc 1 544 0
 1633 01ea 10E0      		ldi r17,0
 1634               	.LVL130:
 1635               	.L75:
 544:controller.c  ****                           can_info[1+i] = mcp2515_register_read(can_buffer[1]+i);
 1636               		.loc 1 544 0 is_stmt 0 discriminator 1
 1637 01ec 6B89      		ldd r22,Y+19
 1638 01ee 1617      		cp r17,r22
 1639 01f0 00F4      		brsh .L91
 545:controller.c  ****                         put_byte_n(can_info,can_buffer[2]+1);
 1640               		.loc 1 545 0 is_stmt 1 discriminator 3
 1641 01f2 8A89      		ldd r24,Y+18
 1642 01f4 810F      		add r24,r17
 1643 01f6 0E94 0000 		call mcp2515_register_read
 1644               	.LVL131:
 1645 01fa E2E0      		ldi r30,lo8(2)
 1646 01fc F0E0      		ldi r31,0
 1647 01fe EC0F      		add r30,r28
 1648 0200 FD1F      		adc r31,r29
 1649 0202 E10F      		add r30,r17
 1650 0204 F11D      		adc r31,__zero_reg__
 1651 0206 8083      		st Z,r24
 544:controller.c  ****                           can_info[1+i] = mcp2515_register_read(can_buffer[1]+i);
 1652               		.loc 1 544 0 discriminator 3
 1653 0208 1F5F      		subi r17,lo8(-(1))
 1654               	.LVL132:
 1655 020a 00C0      		rjmp .L75
 1656               	.L91:
 1657               	.LVL133:
 546:controller.c  ****                         break;
 1658               		.loc 1 546 0
 1659 020c 6F5F      		subi r22,lo8(-(1))
 1660               	.LVL134:
 1661               	.LBB68:
 1662               	.LBB69:
 119:controller.c  **** }
 1663               		.loc 1 119 0
 1664 020e 70E0      		ldi r23,0
 1665               	.LVL135:
 1666               	.L87:
 1667               	.LBE69:
 1668               	.LBE68:
 1669               	.LBB70:
 1670               	.LBB57:
 1671 0210 CE01      		movw r24,r28
 1672 0212 0196      		adiw r24,1
 1673 0214 0E94 0000 		call usb_serial_write
 1674               	.LVL136:
 1675 0218 00C0      		rjmp .L53
 1676               	.L58:
 1677               	.LVL137:
 1678               	.LBE57:
 1679               	.LBE70:
 1680               	.LBB71:
 1681               	.LBB72:
 112:controller.c  **** }
 1682               		.loc 1 112 0
 1683 021a 80EF      		ldi r24,lo8(-16)
 1684               	.LVL138:
 1685               	.L86:
 1686 021c 0E94 0000 		call usb_serial_putchar_nowait
 1687               	.LVL139:
 1688 0220 00C0      		rjmp .L53
 1689               	.LVL140:
 1690               	.L55:
 1691               	.LBE72:
 1692               	.LBE71:
 554:controller.c  ****                         put_byte_n(can_info,5);
 555:controller.c  ****                         break;
 556:controller.c  ****                     default:
 557:controller.c  ****                         put_byte(NOCAN_HEADER_COMMAND_UNKNOWN);
 558:controller.c  ****                 }
 559:controller.c  ****                 continue;
 560:controller.c  ****             } //  if (usb_serial_available() ...
 561:controller.c  ****             
 562:controller.c  ****             if (bit_is_set(TIFR0,TOV0))
 1693               		.loc 1 562 0
 1694 0222 A89B      		sbis 0x15,0
 1695 0224 00C0      		rjmp .L53
 563:controller.c  ****             {
 564:controller.c  ****                 power_check(&vin_flags, &vin_supply_level, &vin_sense_level,&vref_1_1);
 1696               		.loc 1 564 0
 1697 0226 9E01      		movw r18,r28
 1698 0228 2F5D      		subi r18,-33
 1699 022a 3F4F      		sbci r19,-1
 1700 022c AE01      		movw r20,r28
 1701 022e 4B5D      		subi r20,-37
 1702 0230 5F4F      		sbci r21,-1
 1703 0232 BE01      		movw r22,r28
 1704 0234 6D5D      		subi r22,-35
 1705 0236 7F4F      		sbci r23,-1
 1706 0238 CE01      		movw r24,r28
 1707 023a 8796      		adiw r24,39
 1708 023c 0E94 0000 		call power_check
 1709               	.LVL141:
 565:controller.c  ****                 TCNT0 = 0;
 1710               		.loc 1 565 0
 1711 0240 16BC      		out 0x26,__zero_reg__
 566:controller.c  ****                 TIFR0 |= (1<<TOV0); // clear interrupt flag by putting 1 in place
 1712               		.loc 1 566 0
 1713 0242 A89A      		sbi 0x15,0
 1714 0244 00C0      		rjmp .L53
 1715               		.cfi_endproc
 1716               	.LFE23:
 1718               	.global	packet_id
 1719               		.section .bss
 1722               	packet_id:
 1723 0000 0000      		.zero	2
 1724               	.global	slot_tail
 1727               	slot_tail:
 1728 0002 00        		.zero	1
 1729               	.global	slot_head
 1732               	slot_head:
 1733 0003 00        		.zero	1
 1734               		.comm	circ_buffer,256,1
 1735               		.text
 1736               	.Letext0:
 1737               		.file 4 "/Users/pannetra/avr8-gnu-toolchain-darwin_x86_64/avr/include/stdint.h"
 1738               		.file 5 "usb_serial.h"
 1739               		.file 6 "mcp2515.h"
 1740               		.file 7 "spi.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 controller.c
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:4      *ABS*:000000000000003f __SREG__
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:12     .text.power_up:0000000000000000 power_up
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:34     .text.power_down:0000000000000000 power_down
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:56     .text.get_byte:0000000000000000 get_byte
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:106    .text.put_byte:0000000000000000 put_byte
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:124    .text.put_byte_n:0000000000000000 put_byte_n
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:143    .text.can_recv:0000000000000000 can_recv
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:426    .text.can_send:0000000000000000 can_send
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:663    .text.can_init:0000000000000000 can_init
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:784    .text.adc_read:0000000000000000 adc_read
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:837    .text.power_check:0000000000000000 power_check
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:974    .text.__vector_1:0000000000000000 __vector_1
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:1727   .bss:0000000000000002 slot_tail
                            *COM*:0000000000000100 circ_buffer
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:1722   .bss:0000000000000000 packet_id
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:1732   .bss:0000000000000003 slot_head
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:1112   .text.circ_buffer_pos:0000000000000000 circ_buffer_pos
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:1146   .text.circ_buffer_advance:0000000000000000 circ_buffer_advance
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:1184   .text.circ_buffer_clear:0000000000000000 circ_buffer_clear
/var/folders/sj/f9kxv34128b7m_365p3ps5_h0000gn/T//ccivsE5z.s:1215   .text.startup.main:0000000000000000 main

UNDEFINED SYMBOLS
usb_serial_getchar
usb_serial_putchar_nowait
usb_serial_write
mcp2515_rx_status
spi_transmit
mcp2515_register_write_bit
mcp2515_status
spi_master_init
mcp2515_register_read
mcp2515_register_write
usb_init
usb_configured
usb_serial_flush_input
usb_serial_available
__do_clear_bss
